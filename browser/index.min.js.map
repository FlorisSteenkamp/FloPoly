{"version":3,"sources":["index.min.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","FloPoly","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","_dereq_","coreOperators","rootOperators","rootBounds","allRootsRecursive","random","errorAnalysis","fromRoots","multiply","Object","assign","allRoots","./lib/all-roots-recursive.js","./lib/core-operators.js","./lib/error-analysis.js","./lib/from-roots.js","./lib/random.js","./lib/root-bounds.js","./lib/root-operators.js","2","p","b","clip0","undefined","INF","d","rangeFilter","inRange","quadraticRoots","filter","lowerBound","upperBound","negativeRootLowerBound_LMQ","positiveRootUpperBound_LMQ","dp","differentiate","roots","unshift","push","rootsWithin","x","intervals","peval","evaluate","prevRoot","root","evA","evB","brent","toCasStr","rootMagnitudeUpperBound_fujiwara","positiveRootLowerBound_LMQ","negativeRootUpperBound_LMQ","Number","POSITIVE_INFINITY","./core-operators.js","./root-bounds.js","./root-operators.js","3","equal","p1","p2","add","d1","d2","Δd","Δd1","Δd2","Math","max","result","c1","c2","subtract","negate","multiplyByConst","Array","fill","j","c","degree","evaluateAt0","signChanges","prevSign","sign","deflate","bs","invert","slice","reverse","changeVariables","_i","res","_i2","_j","acc","reflectAboutYAxis","sturmChain","m","pnext","shift","clip","δ","EPSILON","maxCoefficient","abs","p_","str","cStr","toString","4","conditionNumber","pow","hornerErrorBound","5","_require","6","predictiveRandom","seed","RANGE","randomArray","odds","SEED","vs","values","flatRoots","randArr","flatCoefficients","createArrFunction","v","flatRootsArr","flatCoefficientsArr","./from-roots.js","7","maxAbs","ns","apply","map","rootMagnitudeUpperBound_rouche","an","deg","timesUsed","ub","tempub","any","k","powres","POWERS","temp","8","_p","_slicedToArray","delta","sqrt","root1","root2","numRootsWithin","ps","as","bisection","_ref","fa","fb","fc","mflag","fac","fab","fbc","t1","b_c","s_b","c_d","fs","_temp","sliceIterator","arr","_arr","_n","_d","_e","_s","Symbol","iterator","next","done","value","err","isArray","TypeError"],"mappings":"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","file":"index.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.FloPoly = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n'use strict';\n\nvar coreOperators = _dereq_('./lib/core-operators.js');\nvar rootOperators = _dereq_('./lib/root-operators.js');\nvar rootBounds = _dereq_('./lib/root-bounds.js');\nvar allRootsRecursive = _dereq_('./lib/all-roots-recursive.js');\nvar random = _dereq_('./lib/random.js');\nvar errorAnalysis = _dereq_('./lib/error-analysis.js');\nvar fromRoots = _dereq_('./lib/from-roots.js');\n\nvar multiply = coreOperators.multiply;\n\n/**\r\n* <p>\r\n* Simple & fast practical library functions for functional univariate \r\n* polynomials over the reals (actually ECMAScript numbers, i.e. double \r\n* floats).\r\n* </p>\r\n* <p>\r\n* All polinomials are represented as a simple array starting with the \r\n* highest non-zero power, e.g. \r\n*   3x^3 + 5x^2 + 7x + 2 -> [3,5,7,2]\r\n* </p>\r\n* @ignore\r\n*/\nvar FloPoly = Object.assign({}, coreOperators, rootOperators, rootBounds, { random: random }, { fromRoots: fromRoots }, {\n\t\tallRoots: allRootsRecursive\n\t\t//allRootsVAS,\n}, errorAnalysis);\n\nmodule.exports = exports = FloPoly;\n\n},{\"./lib/all-roots-recursive.js\":2,\"./lib/core-operators.js\":3,\"./lib/error-analysis.js\":4,\"./lib/from-roots.js\":5,\"./lib/random.js\":6,\"./lib/root-bounds.js\":7,\"./lib/root-operators.js\":8}],2:[function(_dereq_,module,exports){\n'use strict';\n\nvar coreOperators = _dereq_('./core-operators.js');\nvar rootOperators = _dereq_('./root-operators.js');\nvar rootBounds = _dereq_('./root-bounds.js');\n\nvar brent = rootOperators.brent,\n    quadraticRoots = rootOperators.quadraticRoots;\nvar clip0 = coreOperators.clip0,\n    evaluate = coreOperators.evaluate,\n    differentiate = coreOperators.differentiate,\n    toCasStr = coreOperators.toCasStr;\nvar rootMagnitudeUpperBound_fujiwara = rootBounds.rootMagnitudeUpperBound_fujiwara,\n    positiveRootUpperBound_LMQ = rootBounds.positiveRootUpperBound_LMQ,\n    positiveRootLowerBound_LMQ = rootBounds.positiveRootLowerBound_LMQ,\n    negativeRootUpperBound_LMQ = rootBounds.negativeRootUpperBound_LMQ,\n    negativeRootLowerBound_LMQ = rootBounds.negativeRootLowerBound_LMQ;\n\nvar INF = Number.POSITIVE_INFINITY;\n\n/**\r\n * <p>Finds a near optimal approximation to the real roots (or those \r\n * within a range) of the input polynomial.\r\n * </p>\r\n * <p>\r\n * Only multiple roots of even order that is very close together may be \r\n * missed. (This is rarely a problem in practice - in a geometrical \r\n * application, for instance, this may mean two objects are barely \r\n * touching and returning either, all, or none of the repeated even \r\n * roots should not break the algorithm). \r\n * </p>\r\n * \r\n * @alias allRoots\r\n * @param {number[]} p - The polynomial\r\n * @param {number} a - Lower limit of root values that should be \r\n * returned - defaults to -∞\r\n * @param {number} b - Upper limit of root values that should be \r\n * returned - defaults to +∞\r\n * @returns {number[]} The found roots.\r\n * @impl_notes\r\n * @example\r\n * FloPoly.allRoots([1, -10, 35, -50, 24]); //=> [1, 2.0000000000000036, 3.0000000000000067, 4] \r\n */\nfunction allRootsRecursive(p, a, b) {\n\tp = clip0(p);\n\ta = a === undefined ? -INF : a;\n\tb = b === undefined ? +INF : b;\n\n\tvar d = p.length - 1;\n\tvar rangeFilter = inRange(a, b);\n\n\tif (d === 2) {\n\t\treturn quadraticRoots(p).filter(rangeFilter);\n\t\t// Investigate if any numerically stable algorithm could be as fast\n\t\t// as this algorithm (i.e by finding cubic roots within quadratic\n\t\t// root demarcated intervals via Brent's method. The cubicRoots \n\t\t// algoritm below has been removed since it was numerically \n\t\t// unstable.\n\t\t/*} else if (d === 3) {\r\n  \treturn cubicRoots(p)\r\n  \t\t.filter(rangeFilter)\r\n  \t\t.sort((a,b) => a-b)\r\n  } else if (d > 3) {*/\n\t} else if (d > 2) {\n\t\t// TODO The root bounding function below might have an impact on \n\t\t// performance - it would probably be better to use \n\t\t// positiveRootUpperBound_LMQ or (possibly) even better, the \n\t\t// linear version of it (see paper of Viglas, Akritas and \n\t\t// Strzebonski) and re-calculate bounds on every iteration.\n\t\tvar lowerBound = void 0;\n\t\tvar upperBound = void 0;\n\t\tif (a === -INF || b === +INF) {\n\t\t\t//let magnitudeBound = rootMagnitudeUpperBound_fujiwara(p);\n\t\t\t//lowerBound = a === -INF ? -magnitudeBound : a;\n\t\t\t//upperBound = b === +INF ? +magnitudeBound : b;\n\n\t\t\tif (a === -INF) {\n\t\t\t\tlowerBound = negativeRootLowerBound_LMQ(p);\n\t\t\t} else {\n\t\t\t\tlowerBound = a;\n\t\t\t}\n\t\t\tif (b === +INF) {\n\t\t\t\tupperBound = positiveRootUpperBound_LMQ(p);\n\t\t\t} else {\n\t\t\t\tupperBound = b;\n\t\t\t}\n\t\t} else {\n\t\t\tlowerBound = a;\n\t\t\tupperBound = b;\n\t\t}\n\n\t\t// If the roots of the differentiated polynomial is out of range \n\t\t// then the roots of the polynomial itself will also be out of \n\t\t// range.\n\t\tvar dp = differentiate(p);\n\t\tvar roots = allRootsRecursive(dp, lowerBound, upperBound).filter(rangeFilter);\n\n\t\tif (roots[0] !== lowerBound) {\n\t\t\t// For code coverage to cover the 'else' case we would need\n\t\t\t// to find a case where the lower bound actually matches the\n\t\t\t// root which would be very rare - needs further \n\t\t\t// investigation.\n\n\t\t\t// Not an actual root.\n\t\t\troots.unshift(lowerBound);\n\t\t}\n\t\tif (roots[roots.length - 1] !== upperBound) {\n\t\t\t// Not an actual root.\n\t\t\troots.push(upperBound);\n\t\t}\n\t\treturn rootsWithin(p, roots);\n\t} else if (d === 1) {\n\t\t// Less likely so put near bottom (micro optimization)\n\t\treturn [-p[1] / p[0]].filter(rangeFilter);\n\t} else if (d === 0) {\n\t\treturn []; // y = c -> no roots\t\n\t}\n\n\t// Least likely so put at bottom (micro optimization)\n\t// d === -1\n\t// y = 0 -> infinite number of roots\n\treturn [];\n}\n\n/**\r\n * Returns a function that returns true if x is in the range [a,b].\r\n *  \r\n * @ignore\r\n * @param {number} a\r\n * @param {number} b\r\n * @returns {function}\r\n */\nfunction inRange(a, b) {\n\treturn function (x) {\n\t\treturn x >= a && x <= b;\n\t};\n}\n\n/**\r\n * Finds all roots of the given polynomial within the given intervals.\r\n *  \r\n * @ignore\r\n * @param {number[]} p\r\n * @param {number[]} intervals\r\n * @returns {number[]} The found roots.\r\n */\nfunction rootsWithin(p, intervals) {\n\n\tvar roots = [];\n\tvar peval = evaluate(p);\n\n\tvar prevRoot = void 0;\n\tvar a = intervals[0];\n\tfor (var i = 1; i < intervals.length; i++) {\n\t\tvar root = void 0;\n\t\tvar b = intervals[i];\n\n\t\tvar evA = peval(a);\n\t\tvar evB = peval(b);\n\n\t\tvar k = evA * evB;\n\n\t\tif (k === 0) {\n\t\t\tif (evA === 0) {\n\t\t\t\troot = a;\n\t\t\t} else if (evB === 0 && i === intervals.length - 1) {\n\t\t\t\troot = b;\n\t\t\t}\n\t\t} else if (evA * evB < 0) {\n\t\t\troot = brent(peval, a, b);\n\t\t}\n\n\t\t// Add root if it exists and suppress exact duplicates\n\t\tif (root !== undefined && root !== prevRoot) {\n\t\t\troots.push(root);\n\t\t\tprevRoot = root;\n\t\t}\n\n\t\ta = b;\n\t}\n\n\treturn roots;\n}\n\nmodule.exports = allRootsRecursive;\n\n},{\"./core-operators.js\":3,\"./root-bounds.js\":7,\"./root-operators.js\":8}],3:[function(_dereq_,module,exports){\n'use strict';\n\n/**\r\n * Returns true if two polynomials are exactly equal by comparing \r\n * coefficients.\r\n * \r\n * @param {number[]} p1 - A polynomial\r\n * @param {number[]} p2 - Another polynomial \r\n * @returns {boolean} True if exactly equal, false otherwise.\r\n * @example\r\n * FloPoly.equal([1,2,3,4], [1,2,3,4]);   //=> true\r\n * FloPoly.equal([1,2,3,4], [1,2,3,4,5]); //=> false\r\n */\n\nfunction equal(p1, p2) {\n\tif (p1.length !== p2.length) {\n\t\treturn false;\n\t}\n\tfor (var i = 0; i < p1.length; i++) {\n\t\tif (p1[i] !== p2[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\r\n * Adds two polynomials.\r\n * \r\n * @param {number[]} p1 - The first polynomial\r\n * @param {number[]} p2 - The second polynomial\r\n * @returns {number[]} p1 + p2.\r\n * @example\r\n * FloPoly.add([1,2,3],[3,4]); //=> [1,5,7]\r\n */\nfunction add(p1, p2) {\n\t// Initialize result array  \n\tvar d1 = p1.length - 1;\n\tvar d2 = p2.length - 1;\n\tvar Δd = d1 - d2;\n\n\tvar Δd1 = 0;\n\tvar Δd2 = 0;\n\tif (Δd > 0) {\n\t\tΔd2 = -Δd;\n\t} else if (Δd < 0) {\n\t\tΔd1 = +Δd;\n\t}\n\n\tvar d = Math.max(d1, d2);\n\n\t// Add coefficients\n\tvar result = [];\n\tfor (var i = 0; i < d + 1; i++) {\n\t\tvar c1 = p1[i + Δd1];\n\t\tvar c2 = p2[i + Δd2];\n\t\tresult.push((c1 || 0) + (c2 || 0));\n\t}\n\n\t// Ensure the result is a valid polynomial representation\n\treturn clip0(result);\n}\n\n/** \r\n * Subtracts the second polynomial from first.\r\n * \r\n * @param {number[]} p1 - The polynomial from which will be subtracted\r\n * @param {number[]} p2 - The polynomial that will be subtracted\r\n * @returns {number[]} p1 - p2\r\n * @example\r\n * FloPoly.subtract([2,3],[4,4]); //=> [-2, -1]\r\n */\nfunction subtract(p1, p2) {\n\t// Initialize result array  \n\tvar d1 = p1.length - 1;\n\tvar d2 = p2.length - 1;\n\tvar Δd = d1 - d2;\n\n\tvar Δd1 = 0;\n\tvar Δd2 = 0;\n\tif (Δd > 0) {\n\t\tΔd2 = -Δd;\n\t} else if (Δd < 0) {\n\t\tΔd1 = +Δd;\n\t}\n\n\tvar d = Math.max(d1, d2);\n\n\t// Add coefficients\n\tvar result = [];\n\tfor (var i = 0; i < d + 1; i++) {\n\t\tvar c1 = p1[i + Δd1];\n\t\tvar c2 = p2[i + Δd2];\n\t\tresult.push((c1 || 0) - (c2 || 0));\n\t}\n\n\t// Ensure the result is a valid polynomial representation\n\treturn clip0(result);\n}\n\n/**\r\n * Negate the given polynomial (p -> -p).  \r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number[]} -p\r\n * @example\r\n * FloPoly.negate([0.1, -0.2]); //=> [-0.1, 0.2]\r\n */\nfunction negate(p) {\n\treturn multiplyByConst(-1, p);\n}\n\n/**  \r\n * Differentiates the given polynomial.\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number[]} D(p)\r\n * @example\r\n * FloPoly.differentiate([5, 4, 3, 2, 1]); //=> [20, 12, 6, 2]\r\n */\nfunction differentiate(p) {\n\n\tvar result = [];\n\n\tvar d = p.length - 1;\n\tfor (var i = 0; i < d; i++) {\n\t\tresult.push((d - i) * p[i]);\n\t}\n\n\treturn result;\n}\n\n/**\r\n * <p> \r\n * Multiplies the two given polynomials and returns the result. \r\n * </p>\r\n * <p>\r\n * See <a href=\"https://en.wikipedia.org/wiki/Polynomial_arithmetic\">polynomial arithmetic</a>\r\n * </p>\r\n * <p>\r\n * See <a href=\"https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Polynomial_multiplication\">polynomial multiplication</a>\r\n * </p>\r\n * <p>\r\n * See <a herf=\"http://web.cs.iastate.edu/~cs577/handouts/polymultiply.pdf\">polynomial multiplication (pdf)</a>\r\n * </p>\r\n * @param {number[]} p1 - The one polynomial.\r\n * @param {number[]} p2 - The other polynomial.\r\n * @returns {number[]} p1 * p2\r\n * @example\r\n * FloPoly.multiply([1,2,3], [2,5,3,5]); //=> [2, 9, 19, 26, 19, 15]\r\n */\n// TODO Currently using O(n^2) algorithm - possibly change to a faster  \n// FFT algorithm for high degree polynomials? No, we are interested in\n// polynomials of degree 20 or lower.\nfunction multiply(p1, p2) {\n\tvar d1 = p1.length - 1;\n\tvar d2 = p2.length - 1;\n\tvar d = d1 + d2;\n\n\tvar result = new Array(d + 1).fill(0);\n\tfor (var i = 0; i < d1 + 1; i++) {\n\t\tfor (var j = 0; j < d2 + 1; j++) {\n\t\t\tresult[d - (i + j)] += p1[d1 - i] * p2[d2 - j];\n\t\t}\n\t}\n\n\treturn clip0(result);\n}\n\n/** \r\n * Multiplies 2 polynomials by a constant.\r\n * \r\n * @param {number} c - The constant\r\n * @param {number[]} p - The polynomial\r\n * @returns {number[]} c*p\r\n * @example \r\n * FloPoly.multiplyByConst(0.25, [3,2,1]); //=> [0.75, 0.5, 0.25]  \r\n */\nfunction multiplyByConst(c, p) {\n\tif (c === 0) {\n\t\treturn [];\n\t}\n\n\tvar d = p.length - 1;\n\tvar result = [];\n\tfor (var i = 0; i < d + 1; i++) {\n\t\tresult.push(c * p[i]);\n\t}\n\n\t// We have to clip due to possible floating point underflow\n\treturn clip0(result);\n}\n\n/** \r\n * Returns the degree of the polynomial.\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number} \r\n * @example \r\n * FloPoly.degree([9,8,7,6,5,4,3,2,1]); //=> 9\r\n */\nfunction degree(p) {\n\treturn p.length - 1;\n}\n\n/** \r\n * Evaluates a univariate polynomial using Horner's method. This \r\n * function is curried (see examples below).  \r\n * \r\n * @see https://en.wikipedia.org/wiki/Horner%27s_method\r\n * @param {number[]} p - The polynomial\r\n * @param {number} a - The value at which to evaluate the polynomial.\r\n * @returns {number|function} The result if both parameters are supplied\r\n * or a function with arity one if only the first parameter is supplied.\r\n * @example\r\n * let ev = FloPoly.evaluate([3,2,1]);\r\n * ev(1); // => 6\r\n * ev(2); // => 17\r\n * \t\t \r\n * FloPoly.evaluate([3,2,1], 1); // => 6\r\n * FloPoly.evaluate([3,2,1], 2); // => 17\r\n * \r\n * FloPoly.evaluate([3,2,1])(1); // => 6\r\n * FloPoly.evaluate([3,2,1])(2); // => 17\r\n */\nfunction evaluate(p, a) {\n\tfunction evaluate(a) {\n\t\t//if p.length === 0 { return 0; }\n\t\tvar result = p[0];\n\t\tfor (var i = 1; i < p.length; i++) {\n\t\t\tresult = p[i] + result * a;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// Curry the function\n\treturn a === undefined ? evaluate : evaluate(a);\n}\n\n/** \r\n * Evaluates the given polynomial at 0 - it is much faster than at an \r\n * arbitrary point. \r\n *  \r\n * @param {number[]} p - The polynomial\r\n * @returns {number}\r\n * @example\r\n * FloPoly.evaluateAt0([3,2,99]); //=> 99\r\n */\nfunction evaluateAt0(p) {\n\treturn p[p.length - 1];\n};\n\n/** \r\n * <p>\r\n * Returns the number of sign changes in the polynomial coefficents \r\n * when ordered in descending order; zeros are ignored.\r\n * </p>\r\n * <p>\r\n * Descartes' rule of signs states (quoted from Wikipedia):\r\n * \"if the terms of a polynomial are ordered by descending variable \r\n * exponent, then the number of positive roots of the polynomial is \r\n * either equal to the number of sign differences between consecutive \r\n * nonzero coefficients, or is less than it by an even number. Multiple \r\n * roots of the same value are counted separately.\"\r\n * </p>\r\n * @see https://en.wikipedia.org/wiki/Descartes%27_rule_of_signs\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number} The number of sign changes.\r\n * @example\r\n * FloPoly.signChanges([1,2,-3,0,0,3,-1]); //=> 3\r\n */\nfunction signChanges(p) {\n\tvar d = p.length - 1;\n\n\tvar result = 0;\n\tvar prevSign = Math.sign(p[0]);\n\tfor (var i = 1; i < d + 1; i++) {\n\t\tvar sign = Math.sign(p[i]);\n\n\t\tif (sign !== prevSign && sign !== 0) {\n\t\t\tresult++;\n\t\t\tprevSign = sign;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\r\n * Deflates the given polynomial by removing a factor (x - r), where\r\n * r is a root of the polynomial.\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @param {number} root - A pre-calculated root of the polynomial.\r\n * @returns {number[]} The deflated polynomial.\r\n * @example\r\n * // The polynomial x^3 - 5x^2 + 8x - 4 has a root at 1 and a double root at 2 \r\n * FloPoly.deflate([1, -5, 8, -4], 2); //=> [1, -3, 2] \r\n * FloPoly.deflate([1, -3, 2], 2);     //=> [1,-1] \r\n * FloPoly.deflate([1, -1], 1);        //=> [1]\r\n */\nfunction deflate(p, root) {\n\tvar d = p.length - 1;\n\tvar bs = [p[0]];\n\tfor (var i = 1; i < d; i++) {\n\t\tbs.push(p[i] + root * bs[i - 1]);\n\t}\n\n\treturn bs;\n}\n\n/**\r\n * Inverts the given polynomial by reversing the order of the \r\n * coefficients.\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number} p(x) -> x^deg(p) * p(1/x)\r\n * @example\r\n * FloPoly.invert([1,2,3,4]); // => [4,3,2,1]\r\n * FloPoly.invert([3,2,-5]);  // => [-5,2,3]\r\n */\nfunction invert(p) {\n\treturn p.slice().reverse();\n}\n\n/**\r\n * <p> \r\n * Performs a change of variables of the form: p(x) <- p(ax + b).\r\n * </p>\r\n * <p>\r\n * See <a href=\"http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system\">this stackoverflow question</a>\r\n * </p>\r\n * @param {number[]} p - The polynomial\r\n * @param {number} a\r\n * @param {number} b\r\n * @returns {number[]} The transformed polynomial.\r\n * @example\r\n * FloPoly.changeVariables([1,2,7], 3, 4); //=> [9, 30, 31]\r\n */\nfunction changeVariables(p, a, b) {\n\t// We let the coefficients of p(ax + b) be denoted by d_i in the \n\t// code below. \n\t// d_i is calculated as d = T*c, where c are the original \n\t// coefficients.\n\n\tvar d = p.length - 1;\n\n\t// Initialize a zero matrix\n\tvar t = [];\n\tfor (var i = 0; i < d + 1; i++) {\n\t\tt.push(new Array(d + 1).fill(0));\n\t}\n\n\t// Calculate the triangular matrix T\n\tt[0][0] = 1;\n\tfor (var j = 1; j <= d; j++) {\n\t\tt[0][j] = b * t[0][j - 1];\n\t\tfor (var _i = 1; _i <= j; _i++) {\n\t\t\tt[_i][j] = b * t[_i][j - 1] + a * t[_i - 1][j - 1];\n\t\t}\n\t}\n\n\t// Multiply\n\tvar res = new Array(d + 1).fill(0);\n\tfor (var _i2 = 0; _i2 <= d; _i2++) {\n\t\tres[d - _i2] = 0;\n\t\tfor (var _j = _i2; _j <= d; _j++) {\n\t\t\tvar acc = t[_i2][_j] * p[d - _j];\n\t\t\tres[d - _i2] += acc;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n/**\r\n * Reflects the given polynomial about the Y-axis, i.e. perform the \r\n * change of variables: p(x) <- p(-x).\r\n * \r\n * @param {number[]} p - The polynomial to reflect\r\n * @returns {number[]} The reflected polynomial.\r\n * @example\r\n * FloPoly.reflectAboutYAxis([5,4,3,2,1]); //=> [5, -4, 3, -2, 1]\r\n */\nfunction reflectAboutYAxis(p) {\n\tvar d = p.length - 1;\n\n\tvar result = p.slice();\n\tfor (var i = 0; i < d + 1; i++) {\n\t\tif (i % 2) {\n\t\t\tresult[i] = -result[i];\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/** \r\n * Generates a sturm chain for the given polynomial.\r\n * \r\n * @see https://en.wikipedia.org/wiki/Sturm%27s_theorem\r\n * @param {number[]} p - The polynomial\r\n * @returns {number[][]} The sturm chain of polynomials\r\n * @example\r\n * FloPoly.sturmChain([-3,4,2,-2]); //=> [[-3, 4, 2, -2], [-9, 8, 2], [-2.5185185185185186, 1.7037037037037037], [-3.2932525951557086]]\r\n */\nfunction sturmChain(p) {\n\n\t/** \r\n  * Returns the negative of the remainder when dividing the first \r\n  * polynomial (the dividend) by the second (the divisor) provided \r\n  * that deg(p1) - deg(p2) === 1.\r\n  * \r\n  * @ignore\r\n  * @param {number[]} p1 - The first polynomial (dividend)\r\n  * @param {number[]} p2 - The second polynomial (divisor)\r\n  * @see https://en.wikipedia.org/wiki/Sturm%27s_theorem\r\n  */\n\tfunction negRemainder(p1, p2) {\n\t\tvar d1 = p1.length - 1;\n\t\tvar d2 = p2.length - 1;\n\t\tvar d = d1 - d2;\n\n\t\tvar a = p1[1] / p1[0] - p2[1] / p2[0];\n\t\tvar b = p1[0] / p2[0];\n\n\t\tvar p3 = multiply(multiplyByConst(b, p2), [1, a]);\n\n\t\treturn subtract(p3, p1);\n\t}\n\n\tvar m = []; // Sturm chain\n\tm.push(p);\n\tm.push(differentiate(p));\n\n\t//const δ = 10 * Number.EPSILON;\n\tvar i = 1;\n\twhile (m[i].length - 1 > 0) {\n\t\tvar pnext = negRemainder(m[i - 1], m[i]);\n\t\t//pnext = clip(pnext, δ);\n\t\t// If the polynomial degree was not reduced due to roundoff\n\t\t// such that the first 1 or more terms are very small.\n\t\twhile (m[i].length - pnext.length < 1) {\n\t\t\tpnext.shift();\n\t\t}\n\t\t/*\r\n  if (pnext.length === 0) {\r\n  \tbreak;\r\n  }\r\n  */\n\t\tm.push(pnext);\n\n\t\ti++;\n\t}\n\n\treturn m;\n}\n\n/**\r\n * If the highest power coefficient is small in the sense that the \r\n * highest power term has a negligible contribution (compared to the\r\n * other terms) at x = 1 then clip() can be called to remove all such \r\n * highest terms. A contribution of less than Number.EPSILON of the \r\n * highest coefficient will be considered negligible by default.\r\n * \r\n * \r\n * @param {number[]} p - The polynomial to be clipped.\r\n * @param {number} δ - The optional contribution tolerence else \r\n *        Number.EPSILON will be used by default.   \r\n * @returns {number[]} The clipped polynomial.\r\n * @example\r\n * FloPoly.clip([1e-18, 1e-10, 1e-5]); //=> [1e-18, 1e-10, 1e-5] \r\n * FloPoly.clip([1e-18, 1e-10, 1e-1]); //=> [1e-10, 1e-1]\r\n */\nfunction clip(p, δ) {\n\tδ = δ === undefined ? Number.EPSILON : δ;\n\n\tvar c = maxCoefficient(p);\n\tif (c === 0) {\n\t\treturn [];\n\t}\n\n\tif (Math.abs(p[0]) > δ * c) {\n\t\treturn p;\n\t}\n\n\tvar p_ = p.slice(1);\n\twhile (Math.abs(p_[0]) < δ * c) {\n\t\tp_ = p_.slice(1);\n\t}\n\n\treturn clip(p_, δ);\n}\n\n/**\r\n * If the highest power coefficient is 0 then clip() can be called to \r\n * remove all such highest terms so that the array is a valid \r\n * presentation of a polynomial.\r\n * \r\n * @param {number[]} p - The polynomial to be clipped.\r\n * @returns {number[]} The clipped polynomial.\r\n * @example\r\n * FloPoly.clip0([1e-18, 1e-10, 1e-1]); //=> [1e-18, 1e-10, 1e-1]\r\n * FloPoly.clip0([0, 1e-10, 1e-1]); //=> [1e-10, 1e-1]\r\n */\nfunction clip0(p) {\n\treturn p[0] !== 0 ? p : clip0(p.slice(1));\n}\n\n/**\r\n * Returns the absolute value of the highest coefficient of the \r\n * polynomial.\r\n * \r\n * @param p {number[]} p - The polynomial.\r\n * @returns {number}\r\n * @example\r\n * FloPoly.maxCoefficient([-2, 0.1, 0.2]); //=> 2\r\n */\nfunction maxCoefficient(p) {\n\tvar max = 0;\n\tfor (var i = 0; i < p.length; i++) {\n\t\tvar c = Math.abs(p[i]);\n\t\tif (c > max) {\n\t\t\tmax = c;\n\t\t}\n\t}\n\n\treturn max;\n}\n\n/**\r\n * Returns a string representing the given polynomial that is readable \r\n * by a human or a CAS (Computer Algebra System).\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {string}\r\n * @example\r\n * FloPoly.toCasStr([5,4,3,2,1]); //=> \"x^4*5 + x^3*4 + x^2*3 + x*2 + 1\"\r\n */\nfunction toCasStr(p) {\n\tvar d = p.length - 1;\n\n\tvar str = '';\n\tfor (var i = 0; i < d + 1; i++) {\n\t\tvar cStr = p[i].toString();\n\t\tif (i === d) {\n\t\t\tstr += cStr;\n\t\t} else if (i === d - 1) {\n\t\t\tstr += 'x*' + cStr + ' + ';\n\t\t} else {\n\t\t\tstr += 'x^' + (d - i).toString() + '*' + cStr + ' + ';\n\t\t}\n\t}\n\n\treturn str;\n}\n\nvar coreOperators = {\n\tequal: equal,\n\tadd: add,\n\tsubtract: subtract,\n\tmultiplyByConst: multiplyByConst,\n\tnegate: negate,\n\tdifferentiate: differentiate,\n\tmultiply: multiply,\n\tdegree: degree,\n\tevaluate: evaluate,\n\tevaluateAt0: evaluateAt0,\n\tsignChanges: signChanges,\n\tinvert: invert,\n\tchangeVariables: changeVariables,\n\treflectAboutYAxis: reflectAboutYAxis,\n\tsturmChain: sturmChain,\n\tclip: clip,\n\tclip0: clip0,\n\tdeflate: deflate,\n\tmaxCoefficient: maxCoefficient,\n\ttoCasStr: toCasStr\n};\n\nmodule.exports = coreOperators;\n\n},{}],4:[function(_dereq_,module,exports){\n'use strict';\n\nvar coreOperators = _dereq_('./core-operators.js');\n\nvar errorAnalysis = {\n  hornerErrorBound: hornerErrorBound\n};\n\nvar evaluate = coreOperators.evaluate;\n\n/**\r\n * <p>\r\n * Approximate condition number for polynomial evaluation multiplied\r\n * by the exact value of the polynomial evaluation.\r\n * </p>\r\n * <p>\r\n * See <a href=\"http://www-pequan.lip6.fr/~jmc/polycopies/Compensation-horner.pdf\">Compensated Horner Scheme - paragraph 1.1</a>\r\n * </p>\r\n * \r\n * @ignore\r\n * @param {number[]} p - The polynomial\r\n * @param {number} x - The evaluation point\r\n * @returns {number} The condition number multiplied exact polynomial \r\n * value at x\r\n */\n\nfunction conditionNumber(p, x) {\n  var d = p.length - 1;\n  var res = 0;\n\n  for (var i = 0; i < d; i++) {\n    res += Math.abs(p[i] * Math.pow(x, d - i));\n  }\n\n  return res;\n}\n\n/**\r\n * <p>\r\n * Classic rule of thumb approximate error bound when using Horner's \r\n * method to evaluate polynomials. \r\n * </p>\r\n * <p>\r\n * See for instance <a href=\"http://www-pequan.lip6.fr/~jmc/polycopies/Compensation-horner.pdf\">compensated horner evaluation</a>\r\n * </p>\r\n * @param p {number[]} - The polynomial\r\n * @param x {number} - Value at which polynomial is evaluated. \r\n * @returns {number} The error bound\r\n * @example\r\n * hornerErrorBound([1.1,2.2,-3.3], 1.5); //=> 5.1292303737682235e-15 \r\n */\nfunction hornerErrorBound(p, x) {\n  var δ = Number.EPSILON;\n\n  var d = p.length - 1;\n  return 2 * d * δ * conditionNumber(p, x);\n}\n\nmodule.exports = errorAnalysis;\n\n},{\"./core-operators.js\":3}],5:[function(_dereq_,module,exports){\n'use strict';\n\nvar _require = _dereq_('./core-operators.js'),\n    multiply = _require.multiply;\n\n/**\r\n * <p>\r\n * Constructs a polynomial from the given roots by multiplying out the \r\n * factors (x - root1)(x - root2)... Note that the resulting polynomial \r\n * will not have any complex roots.\r\n * </p>\r\n * <p>\r\n * Mostly provided for testing purposes. Note that the real roots of the \r\n * constructed polynomial may not be exactly the same as the roots that\r\n * the polynomial has been constructed from due to floating-point \r\n * round-off.\r\n * </p>\r\n * \r\n * @param {number[]} roots - The roots\r\n * @returns {number[]} The constructed polynomial.\r\n * @example\r\n * FloPoly.fromRoots([1,2,3,3]); //=> [1, -9, 29, -39, 18]\r\n * FloPoly.allRoots([1, -9, 29, -39, 18]); //=> [1.0000000000000007, 2.000000000000004]\r\n * // In the above note the rounding error. Also note the multiple root of 3 that has been missed but as stated previously this does not generally pose a problem for even multiple roots. See the examples below.\r\n * FloPoly.allRoots([1, -9, 29, -39, 17.99999999999999]); //=> [0.9999999999999973, 2.00000000000002, 2.9999999999999982]\r\n * FloPoly.allRoots([1, -9, 29, -39, 17.9999999999999]); //=> [0.999999999999975, 2.0000000000000986, 2.9999997898930832, 3.0000002095475775]\r\n */\n\nfunction fromRoots(roots) {\n  var p = [1];\n  for (var i = 0; i < roots.length; i++) {\n    p = multiply(p, [1, -roots[i]]);\n  }\n\n  return p;\n}\n\nmodule.exports = fromRoots;\n\n},{\"./core-operators.js\":3}],6:[function(_dereq_,module,exports){\n'use strict';\n\nvar fromRoots = _dereq_('./from-roots.js');\n\n/**\r\n * Some seed value for the simple random number generator.\r\n * @ignore\r\n */\nvar SEED = 123456789;\n\n/**\r\n * The range for the simple random number generator, i.e. the generated\r\n * numbers will be in [0,RANGE].\r\n * @ignore\r\n */\nvar RANGE = 4294967296;\n\n/**\r\n * Generates an array of random polynomials with parameters as specified \r\n * by flatRoots. The exact same polynomials will be created on each\r\n * call to this function if the same seed is used - this is by design to \r\n * improve testability.\r\n *   \r\n * @memberof random\r\n * @param {number} n - The number of polynomials to generate.\r\n * @param {number} d - The degree of the polynomials \r\n * @param {number} a - The lower bound of the distribution - defaults \r\n * to 0\r\n * @param {number} b - The upper bound of the distribution - defaults \r\n * to 1\r\n * @param {number} seed - A seed value for generating random values (so\r\n * that the results are reproducable)\r\n * @param {number} odds - The odds that a root will be doubled (applied\r\n * recursively so that some roots will be tripled, etc. - defaults to 0\r\n * @returns {number[][]} The array of random polynomials.\r\n * @example\r\n * FloPoly.random.flatRootsArr(2,3,0,10); //=> [[1, -17.27247918024659, 97.33487287168995, -179.34094494147305], [1, -14.934967160224915, 57.624514485645406, -14.513933300587215]]\r\n * FloPoly.random.flatRootsArr(2,3,0,10); //=> [[1, -17.27247918024659, 97.33487287168995, -179.34094494147305], [1, -14.934967160224915, 57.624514485645406, -14.513933300587215]]\r\n */\nvar flatRootsArr = createArrFunction(flatRoots);\n\n/**\r\n * Generates an array of random polynomials as specified by \r\n * flatCoefficients. The exact same polynomials will be created on each\r\n * call to this function if the same seed is used - this is by design to \r\n * improve testability.\r\n *   \r\n * @memberof random\r\n * @param {number} n - The number of polynomials to generate.\r\n * @param {number} d - The degree of the polynomials \r\n * @param {number} a - The lower bound of the distribution - defaults \r\n * to 0\r\n * @param {number} b - The upper bound of the distribution - defaults \r\n * to 1\r\n * @param {number} seed - A seed value for generating random values (so\r\n * that the results are reproducable)\r\n * @returns {number[][]} The array of random polynomials.\r\n * @example\r\n * FloPoly.random.flatCoefficientsArr(2,3,-2,2); //=> [[0.1749166026711464, -0.20349335670471191, 0.9375684261322021], [1.0617692470550537, -1.8918039798736572, 0.8040215969085693]]\r\n * FloPoly.random.flatCoefficientsArr(2,3,-2,2); //=> [[0.1749166026711464, -0.20349335670471191, 0.9375684261322021], [1.0617692470550537, -1.8918039798736572, 0.8040215969085693]]\r\n */\nvar flatCoefficientsArr = createArrFunction(flatCoefficients);\n\nvar random = {\n  flatRoots: flatRoots,\n  flatRootsArr: flatRootsArr,\n  flatCoefficients: flatCoefficients,\n  flatCoefficientsArr: flatCoefficientsArr\n\n  /**\r\n   * https://stackoverflow.com/questions/3062746/special-simple-random-number-generator\r\n   * \r\n   * @ignore\r\n   * @param {number} seed\r\n   * @returns {number} A quasi-random number to be used as the next input \r\n   * to this function.\r\n   */\n};function predictiveRandom(seed) {\n  var a = 134775813;\n\n  return (a * seed + 1) % RANGE;\n}\n\n/**\r\n * Generates a random array of numbers picked from a bounded flat \r\n * distribution (i.e. a rectangular distribution) with specified odds of \r\n * duplication of consecutive values.\r\n *   \r\n * @ignore\r\n * @param {number} n - The number of values to generate.\r\n * @param {number} a - The lower bound of the distribution - defaults \r\n * to 0\r\n * @param {number} b - The upper bound of the distribution - defaults \r\n * to 1\r\n * @param {number} seed - A seed value for generating random values (so\r\n * that the results are reproducable)\r\n * @param {number} odds - The odds that a root will be doubled (applied\r\n * recursively so that some roots will be tripled, etc. - defaults to 0\r\n * @returns {number[]} - The random array.\r\n */\nfunction randomArray(n, a, b, seed, odds) {\n  seed = seed === undefined ? SEED : seed;\n  odds = odds === undefined ? 0 : odds;\n\n  var vs = [];\n  for (var i = 0; i < n; i++) {\n    seed = predictiveRandom(seed);\n    var v = seed / RANGE * (b - a) + a;\n    seed = push(seed, vs, v, odds);\n  }\n  vs = vs.slice(0, n);\n\n  return { vs: vs, seed: seed };\n}\n\n/**\r\n * Helper function that will add more numbers to the passed array - \r\n * modifies the values parameter.\r\n *\r\n * @ignore\r\n * @param {number[]} values - An existing array of values - will be \r\n * modified!\r\n * @param {number} x - The number that will be added (possibly\r\n * multiple times)\r\n * @param {number} odds - The odds that the number will be added\r\n * again (recursively). \r\n */\nfunction push(seed, values, x, odds) {\n  seed = predictiveRandom(seed);\n\n  values.push(x);\n  if (seed / RANGE < odds) {\n    seed = push(seed, values, x, odds);\n  }\n\n  return seed;\n}\n\n/**\r\n * Generates a random polynomial with roots picked from a bounded flat \r\n * distribution (i.e. a rectangular distribution) with specified odds of \r\n * duplication of consecutive values. Note that the resulting polynomial\r\n * won't have any complex roots.\r\n * \r\n * @memberof random\r\n * @param {number} d - The degree of the polynomials \r\n * @param {number} a - The lower bound of the distribution - defaults \r\n * to 0\r\n * @param {number} b - The upper bound of the distribution - defaults \r\n * to 1\r\n * @param {number} seed - A seed value for generating random values (so\r\n * that the results are reproducable)\r\n * @param {number} odds - The odds that a root will be doubled (applied\r\n * recursively so that some roots will be tripled, etc. - defaults to 0\r\n * @returns {{p: number[], seed: number}} a random polynomial and the\r\n * last seed value to reuse.\r\n * @example\r\n * FloPoly.random.flatRoots(3,0,10); //=> { p: [1, -17.27247918024659, 97.33487287168995, -179.34094494147305], seed: 939629312 }\r\n */\nfunction flatRoots(d, a, b, seed, odds) {\n  a = a === undefined ? 0 : a;\n  b = b === undefined ? 1 : b;\n  seed = seed === undefined ? SEED : seed;\n  odds = odds === undefined ? 0 : odds;\n\n  var randArr = randomArray(d, a, b, seed, odds);\n  seed = randArr.seed;\n\n  var p = fromRoots(randArr.vs);\n\n  return { p: p, seed: seed };\n}\n\n/**\r\n * Generates a random polynomial with coefficients picked from a bounded \r\n * flat distribution (i.e. a rectangular distribution). \r\n * \r\n * @memberof random\r\n * @param {number} d - The degree of the polynomials \r\n * @param {number} a - The lower bound of the distribution - defaults \r\n * to -1\r\n * @param {number} b - The upper bound of the distribution - defaults \r\n * to 1\r\n * @param {number} seed - A seed value for generating random values (so\r\n * that the results are reproducable)\r\n * @returns {{p: number[], seed: number}} a random polynomial and the\r\n * last seed value to reuse.\r\n * @example\r\n * FloPoly.random.flatCoefficients(3,-5,5); //=> { p: [0.437291506677866, -0.5087333917617798, 2.3439210653305054], seed: 939629312 }\r\n */\nfunction flatCoefficients(d, a, b, seed) {\n  a = a === undefined ? -1 : a;\n  b = b === undefined ? +1 : b;\n  seed = seed === undefined ? SEED : seed;\n\n  var randArr = randomArray(d, a, b, seed);\n  seed = randArr.seed;\n\n  var p = randArr.vs;\n\n  return { p: p, seed: seed };\n}\n\n/**\r\n * Creates a function from the given function with parameters similar\r\n * to flatRoots but with an extra parameter in the beginning indicating\r\n * the length of the array generated by the original function.\r\n * \r\n * @ignore\r\n * @param {function} f\r\n * @returns {function}\r\n */\nfunction createArrFunction(f) {\n  return function (n, d, a, b, seed, odds) {\n    seed = seed === undefined ? SEED : seed;\n    var res = [];\n\n    for (var i = 0; i < n; i++) {\n      var v = f(d, a, b, seed, odds);\n      var p = v.p;\n      seed = v.seed;\n\n      res.push(p);\n    }\n\n    return res;\n  };\n}\n\nmodule.exports = random;\n\n},{\"./from-roots.js\":5}],7:[function(_dereq_,module,exports){\n'use strict';\n\nvar coreOperators = _dereq_('./core-operators.js');\n\nvar invert = coreOperators.invert,\n    negate = coreOperators.negate,\n    reflectAboutYAxis = coreOperators.reflectAboutYAxis;\n\nvar rootBounds = {\n\trootMagnitudeUpperBound_fujiwara: rootMagnitudeUpperBound_fujiwara,\n\tpositiveRootUpperBound_LMQ: positiveRootUpperBound_LMQ,\n\tpositiveRootLowerBound_LMQ: positiveRootLowerBound_LMQ,\n\tnegativeRootUpperBound_LMQ: negativeRootUpperBound_LMQ,\n\tnegativeRootLowerBound_LMQ: negativeRootLowerBound_LMQ,\n\trootMagnitudeUpperBound_rouche: rootMagnitudeUpperBound_rouche\n\n\t/**\r\n  * Returns the maximum magnitude value within the supplied array of \r\n  * numbers.\r\n  * @ignore \r\n  */\n};function maxAbs(ns) {\n\treturn Math.max.apply(null, ns.map(function (n) {\n\t\treturn Math.abs(n);\n\t}));\n}\n\n/**\r\n * Finds an upper bound on the magnitude (absolute value) of the roots\r\n * (including complex roots) of the given polynomial using Rouche's \r\n * Theorem with k = n. This function is fast but the bound is not tight.\r\n * \r\n * @param p {number[]} p - The polynomial.\r\n * @returns {number} The bound.\r\n */\nfunction rootMagnitudeUpperBound_rouche(p) {\n\tvar d = p.length - 1;\n\tvar R = 1 + 1 / p[0] * maxAbs(p.slice(1));\n\treturn R;\n}\n\n/**\r\n * Finds an upper bound on the magnitude (absolute value) of the roots\r\n * of the given polynomial using the near-optimal Fujiwara bound. Note\r\n * that the bound includes complex roots. The bound is tight but slow \r\n * due to usage of Math.pow().\r\n * \r\n * @see https://en.wikipedia.org/wiki/Properties_of_polynomial_roots#cite_note-Fujiwara1916-4\r\n * \r\n * @param {number[]} p - The polynomial.\r\n * @returns {number} The bound.\r\n * @example\r\n * FloPoly.rootMagnitudeUpperBound_fujiwara([2,-3,6,5,-130]); //=> 6.753296750770361\r\n * FloPoly.allRoots([2,-3,6,5,-130]); //=> [-2.397918624065303, 2.8793785310848383]\r\n */\nfunction rootMagnitudeUpperBound_fujiwara(p) {\n\tvar d = p.length - 1;\n\n\tvar an = p[0];\n\tvar bs = [];\n\n\tfor (var i = 1; i < d; i++) {\n\t\tvar b = Math.pow(Math.abs(p[i] / an), 1 / i);\n\t\tbs.push(b);\n\t}\n\n\tbs.push(Math.pow(Math.abs(p[d] / 2 * an), 1 / d));\n\n\treturn 2 * Math.max.apply(undefined, bs);\n}\n\nvar POWERS = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152];\n/**\r\n * <p> \r\n * Returns an upper bound for the positive real roots of the given \r\n * polynomial.\r\n * </p>\r\n * <p>\r\n * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński, \r\n * specifically the LocalMaxQuadratic algorithm hence LMQ.\r\n * </p>  \r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number} A lower bound.\r\n * @example\r\n * FloPoly.positiveRootUpperBound_LMQ([2,-3,6,5,-130]); //=> 4.015534272870436 \r\n * FloPoly.positiveRootUpperBound_LMQ([2,3]);           //=> 0 \r\n * FloPoly.positiveRootUpperBound_LMQ([-2,-3,-4]);      //=> 0\r\n */\nfunction positiveRootUpperBound_LMQ(p) {\n\tvar deg = p.length - 1;\n\tif (deg < 1) {\n\t\treturn 0;\n\t}\n\n\tif (p[0] < 0) {\n\t\tp = negate(p);\n\t}\n\n\tvar timesUsed = [];\n\tfor (var i = 0; i < deg; i++) {\n\t\ttimesUsed.push(1);\n\t}\n\n\tvar ub = 0;\n\n\tfor (var m = 0; m <= deg; m++) {\n\t\tif (p[m] >= 0) continue;\n\n\t\tvar tempub = Number.POSITIVE_INFINITY;\n\t\tvar any = false;\n\n\t\tfor (var k = 0; k < m; k++) {\n\t\t\tif (p[k] <= 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Table lookup is about 70% faster but both are\n\t\t\t// extemely fast anyway. \n\t\t\t// Result is at https://www.measurethat.net/Benchmarks/ShowResult/6610\n\t\t\tvar pow = timesUsed[k];\n\t\t\tvar powres = void 0;\n\t\t\tif (pow > 20) {\n\t\t\t\tpowres = Math.pow(2, pow);\n\t\t\t} else {\n\t\t\t\tpowres = POWERS[pow];\n\t\t\t}\n\t\t\tvar temp = Math.pow(-p[m] / (p[k] / powres), 1 / (m - k));\n\n\t\t\ttimesUsed[k]++;\n\n\t\t\tif (tempub > temp) {\n\t\t\t\ttempub = temp;\n\t\t\t}\n\n\t\t\tany = true;\n\t\t}\n\n\t\tif (any && ub < tempub) ub = tempub;\n\t}\n\n\treturn ub;\n}\n\n/**\r\n * <p> \r\n * Calculates a lower bound for the positive roots of the given \r\n * polynomial.\r\n * </p>\r\n * <p>\r\n * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński, \r\n * specifically the LocalMaxQuadratic algorithm hence LMQ.\r\n * </p>\r\n *  \r\n * @param {number[]} p - The polynomial\r\n * @returns {number} A lower bound.\r\n * @example\r\n * FloPoly.positiveRootLowerBound_LMQ([2,-3,6,5,-130]); //=> 1.6883241876925903\r\n * FloPoly.positiveRootLowerBound_LMQ([2,3]);           //=> 0 \r\n * FloPoly.positiveRootLowerBound_LMQ([-2,-3,-4]);      //=> 0\r\n */\nfunction positiveRootLowerBound_LMQ(p) {\n\tvar ub = positiveRootUpperBound_LMQ(invert(p));\n\tif (ub === 0) {\n\t\treturn 0;\n\t}\n\treturn 1 / ub;\n}\n\n/**\r\n * See positiveRootUpperBound_LMQ\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number} An upper bound.\r\n */\nfunction negativeRootUpperBound_LMQ(p) {\n\treturn -positiveRootLowerBound_LMQ(reflectAboutYAxis(p));\n}\n\n/**\r\n * See positiveRootLowerBound_LMQ\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number} A lower bound.\r\n */\nfunction negativeRootLowerBound_LMQ(p) {\n\treturn -positiveRootUpperBound_LMQ(reflectAboutYAxis(p));\n}\n\nmodule.exports = rootBounds;\n\n},{\"./core-operators.js\":3}],8:[function(_dereq_,module,exports){\n'use strict';\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];var _n = true;var _d = false;var _e = undefined;try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;_e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }return _arr;\n  }return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar coreOperators = _dereq_('./core-operators.js');\n\n/**\r\n * Operators (i.e. functions) directly related to roots and root \r\n * finding. \r\n * \r\n * @ignore\r\n */\nvar rootOperators = {\n  quadraticRoots: quadraticRoots,\n  //cubicRoots,\n  numRootsWithin: numRootsWithin,\n  brent: brent,\n  bisection: bisection\n};\n\nvar sturmChain = coreOperators.sturmChain,\n    evaluate = coreOperators.evaluate,\n    signChanges = coreOperators.signChanges;\n\n/**\r\n * <p>\r\n * Floating-point-stably calculates and returns the ordered quadratic \r\n * roots of the given quadratic polynomial.\r\n * </p>\r\n * <p>\r\n * This function is included only because it might be slightly faster\r\n * than calling allRoots due to allRoots first checking if the \r\n * polynomial is quadratic and checking if the roots are within the\r\n * given range.\r\n * </p>\r\n * @param {number[]} p - The 2nd order polynomial\r\n * @returns {number[]} The found quadratic roots.\r\n * @example \r\n * FloPoly.quadraticRoots([1, -3, 2]); //=> [1,2]\r\n */\n\nfunction quadraticRoots(p) {\n  var _p = _slicedToArray(p, 3),\n      a = _p[0],\n      b = _p[1],\n      c = _p[2];\n\n  var delta = b * b - 4 * a * c;\n\n  if (delta < 0) {\n    // No real roots;\n    return [];\n  }\n\n  if (delta === 0) {\n    return [-b / (2 * a)];\n  }\n\n  delta = Math.sqrt(delta);\n\n  var root1 = void 0;\n  var root2 = void 0;\n  if (b >= 0) {\n    root1 = (-b - delta) / (2 * a);\n    root2 = 2 * c / (-b - delta);\n  } else {\n    root1 = 2 * c / (-b + delta);\n    root2 = (-b + delta) / (2 * a);\n  }\n\n  if (root1 < root2) {\n    return [root1, root2];\n  }\n  return [root2, root1];\n}\n\n/**\r\n * Calculates the roots of the given cubic polynomial.\r\n * \r\n * This code is mostly from the Pomax guide found at\r\n * https://pomax.github.io/bezierinfo/#extremities\r\n * \r\n * @param {number[]} p - A cubic polynomial.\r\n * @returns {number[]} 1,2 or 3 roots.\r\n */\n// TODO - This function as it currently stands is very sensitive to\n// the first coefficient if it is very small, e.g. compare:\n// cubicRoots([1e-5, 1560,-1740,96]) = [1.1903631761670113, -156000001.1153846, -0.07497859001159668] \n// vs\n// quadraticRoots([1560,-1740,96]) = [0.05821032751613551, 1.0571742878684798]\n// It is completely useless in some ranges of its input domain:\n// the part of the function 'if (discriminant < 0) {}'\n// is highly problematic for numerical stability.\n// Simply use allRoots / allRootsRecursive instead.\n/*\r\nfunction cubicRoots(p) {\r\n\r\n\tfunction cuberoot(v) {\r\n\t\treturn v < 0 \r\n\t\t\t? -Math.pow(-v, 1/3)\r\n\t\t    : +Math.pow(v, 1/3);\r\n\t}\r\n\t\r\n\tlet cbrt = Math.cbrt || cuberoot;\r\n\t\r\n\tlet d = p[0];\r\n\tlet a = p[1] / d;\r\n\tlet b = p[2] / d;\r\n\tlet c = p[3] / d;\r\n\t\r\n\tlet s  = (3*b - a*a) / 9;\r\n\tlet q  = (2*a*a*a - 9*a*b + 27*c) / 54;\r\n\t\r\n\tlet s3 = s*s*s;\r\n\tlet q2 = q*q;\r\n\t\r\n\tlet discriminant = q2 + s3;\r\n\r\n\tif (!Number.isFinite(discriminant)) {\r\n\t\t\r\n\t\t// Overflow occured - in which case one root will be very large. \r\n\t\t// We might want to report such large roots as positive or\r\n\t\t// negative infinity but since they are rarely of interest we\r\n\t\t// report only the smaller roots.\r\n\t\t\r\n\t\t// Here q*q   === (729*c^2 - 486*a*b*c + 108*a^3*c + 81*a^2*b^2 - 36*a^4*b + 4*a^6) / (729*4)\r\n\t\t// and  s*s*s === (27*b^3 - 27*a^2*b^2 + 9*a^4*b - a^6) / (729*1)\r\n\t\t\r\n\t\treturn quadraticRoots(p.slice(1)); \r\n\t}\r\n\t\r\n\tif (discriminant < 0) {\r\n\t\t// three real roots\r\n\t\t\r\n\t\tlet r = Math.sqrt(-s3);\r\n\t\tlet t = -q / r;\r\n\t\t\r\n\t\tlet cosphi = t < -1 ? -1 : t > 1 ? 1 : t;\r\n\t\tlet phi    = Math.acos(cosphi);\r\n\t\tlet\tt1     = 2*cbrt(r);\r\n\t\t\r\n\t\tlet ao3 = a/3; \r\n\t\t\r\n\t\treturn [\r\n\t\t\tt1*Math.cos((phi            )/3) - ao3, \r\n\t\t\tt1*Math.cos((phi + 2*Math.PI)/3) - ao3, \r\n\t\t\tt1*Math.cos((phi + 4*Math.PI)/3) - ao3\r\n\t\t]\r\n\t} else if (discriminant === 0) {\r\n\t\t// three real roots, but two of them are equal\r\n\t\t\r\n\t\tlet u1 = q < 0 ? cbrt(-q) : -cbrt(q);\r\n\t\tlet ao3 = a/3;\r\n\t\t\r\n\t\treturn [\r\n\t\t\t2*u1 - ao3, \r\n\t\t\t-u1 - ao3\r\n\t\t];\r\n\t} else {\r\n\t\t// one real root, two complex roots\r\n\t\t\r\n\t\tlet sd = Math.sqrt(discriminant);\r\n\t\tlet u1 = cbrt(sd - q);\r\n\t\tlet v1 = cbrt(sd + q);\r\n\t\t\r\n\t\treturn [u1 - v1 - a/3];\r\n\t}\r\n}\r\n*/\n\n/** \r\n * Returns the number of real roots in the interval (a,b) of the given \r\n * polynomial.\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @param {number} a - The lower bound\r\n * @param {number} b - The upper bound\r\n * @returns {number} The number of roots in the given interval\r\n * @example \r\n * let p = [1, 1, -64, 236, -240];\r\n * FloPoly.numRootsWithin(p,-20,-11); //=> 0\r\n * FloPoly.numRootsWithin(p,-11,-9);  //=> 1  \r\n * FloPoly.numRootsWithin(p,-11,3.5); //=> 3\r\n * FloPoly.numRootsWithin(p,-11,5);   //=> 4\r\n */\nfunction numRootsWithin(p, a, b) {\n  var ps = sturmChain(p);\n  var ev = evaluate(p);\n  var as = ps.map(function (p) {\n    return evaluate(p)(a);\n  });\n  var bs = ps.map(function (p) {\n    return evaluate(p)(b);\n  });\n\n  return signChanges(as) - signChanges(bs);\n}\n\n/**\r\n * <p>\r\n * Searches an interval (a,b) for a root (i.e. zero) of the \r\n * given function with respect to its first argument using the Bisection \r\n * Method root-finding algorithm. Any function can be supplied (it does\r\n * not even have to be continuous) as long as the root is bracketed. \r\n * </p>\r\n * <p>\r\n * Note: This function has no advantages above the Brent method except\r\n * for its simpler implementation and can be much slower. Use brent \r\n * instead.\r\n * </p>\r\n * @param {function} f - The function for which the root is sought.\r\n * @param {number} a - The lower limit of the search interval.\r\n * @param {number} b - The upper limit of the search interval.\r\n * @returns {number} An estimate of the root to within δ (typically \r\n * about 1e-15 multiplied by the root magnitued).\r\n * @example\r\n * let p = FloPoly.fromRoots([-10,2,3,4]);  //=> [1, 1, -64, 236, -240]\r\n * let f = FloPoly.evaluate(p);\r\n * FloPoly.bisection(f,2.2,3.8); //=> 3\r\n * FloPoly.bisection(f,2.2,3.1); //=> 3.0000000000000044\r\n */\nfunction bisection(f, a, b) {\n  if (a === b) {\n    // Presumably the root is already found.\n    return a;\n  } else if (b < a) {\n    // Swap a and b \n    var _ref = [b, a];\n    a = _ref[0];\n    b = _ref[1];\n  }\n\n  var fa = f(a);\n  var fb = f(b);\n\n  if (fa === 0) {\n    return a;\n  }\n  if (fb === 0) {\n    return b;\n  }\n\n  if (fa * fb > 0) {\n    // Root is not bracketed - this is a precondition.\n    throw new Error('Root not bracketed');\n  }\n\n  while (true) {\n    var c = a + (b - a) / 2; // Take midpoint\n    var fc = f(c);\n\n    if (fc === 0) {\n      return c;\n    }\n\n    if (fa * fc < 0) {\n      b = c;\n    } else {\n      a = c;\n    }\n\n    // We don't add Number.EPSILON in the line below because we want\n    // accuracy to improve even below 1.\n    var δ = 2 * Number.EPSILON * Math.abs(b) /*+ Number.EPSILON*/;\n    if (Math.abs(a - b) <= δ) {\n      return b;\n    }\n  }\n}\n\n/**\r\n * <p>\r\n * Searches an interval (a,b) for a root (i.e. zero) of the \r\n * given function with respect to its first argument using the Brent's \r\n * Method root-finding algorithm. Any function can be supplied (it does\r\n * not even have to be continuous) as long as the root is bracketed. \r\n * </p>\r\n * <p>\r\n * Brent's Method is an excellent root-finding choice since it is\r\n * (1) guaranteed to converge (unlike the Newton and other so-called \r\n * single-point methods), (2) converges in a reasonable number of \r\n * iterations even for highly contrived functions (unlike Dekker's \r\n * Method) and (3) nearly always converges extremely fast, i.e. super-\r\n * linearly (unlike the Secant and Regula-Falsi methods).\r\n * </p>\r\n * <p>\r\n * The max error, δ, is set equal to 2*Number.EPSILON*Math.abs(b)\r\n * after each iteration where b is the max of the current 2 best \r\n * guesses.\r\n * </p>\r\n * <p> \r\n * See <a href=\"https://en.wikipedia.org/wiki/Brent%27s_method\">Wikipedia</a>\r\n * </p>\r\n * <p>\r\n * See <a href=\"https://maths-people.anu.edu.au/~brent/pd/rpb011i.pdf\">Brent (page 47)</a>\r\n * </p>\r\n * @param {function} f - The function for which the root is sought.\r\n * @param {number} a - The lower limit of the search interval.\r\n * @param {number} b - The upper limit of the search interval.\r\n * @returns {number} An estimate of the root to within δ (typically \r\n * about 1e-15 multiplied by the root magnitued).\r\n * @example\r\n * let p = FloPoly.fromRoots([-10,2,3,4]);  //=> [1, 1, -64, 236, -240]\r\n * let f = FloPoly.evaluate(p);\r\n * FloPoly.brent(f,2.2,3.8); //=> 3.000000000000003\r\n * FloPoly.brent(f,2.2,3.1); //=> 3.000000000000001\r\n */\nfunction brent(f, a, b) {\n  if (a === b) {\n    // Presumably the root is already found.\n    return a;\n  }\n\n  // We assume on the first iteration f(a) !== 0 && f(b) !== 0. \n  var fa = f(a);\n  var fb = f(b);\n\n  if (fa * fb > 0) {\n    // Root is not bracketed - this is a precondition.\n    throw new Error('Root not bracketed');\n  }\n\n  var c = void 0; // Value of previous guess - set to a initially \n  if (Math.abs(fa) < Math.abs(fb)) {\n    // Swap a,b\n    c = a;a = b;b = c;\n\n    // Swap fa,fb\n    var temp = fa;\n    fa = fb;\n    fb = temp;\n  }\n\n  c = a;\n\n  var mflag = true;\n  var d = void 0; // Value of guess before previous guess\n  while (true) {\n    var δ = 2 * Number.EPSILON * Math.abs(b); // + Number.EPSILON;\n\n    var fc = f(c);\n\n    // Calculate provisional interpolation value\n    var s = void 0;\n    if (fa !== fc && fb !== fc) {\n      // 3 points available - inverse quadratic interpolation\n      var fac = fa - fc;\n      var fab = fa - fb;\n      var fbc = fb - fc;\n\n      // The below has been multiplied out to speed up the algorithm.\n      /*s = ((a * fb * fc) / ( fab * fac)) +\r\n      \t  ((b * fa * fc) / (-fab * fbc)) +\r\n      \t  ((c * fa * fb) / ( fac * fbc));*/\n      s = ((a * fb * fbc - b * fa * fac) * fc + c * fa * fab * fb) / (fab * fac * fbc);\n    } else {\n      // only 2 points available - secant method\n      s = b - fb * ((b - a) / (fb - fa));\n    }\n\n    var t1 = (3 * a + b) / 4;\n    var b_c = Math.abs(b - c);\n    var s_b = Math.abs(s - b);\n    var c_d = Math.abs(c - d);\n\n    if (!( // condition 1\n    s > t1 && s < b || s < t1 && s > b) || mflag && (\n    // condition 2\n    s_b >= b_c / 2 ||\n    // condition 4\n    b_c < δ) || !mflag && (\n    // condition 3\n    s_b >= c_d / 2 ||\n    // condition 5\n    c_d < δ)) {\n      // Bisection\n      s = (a + b) / 2;\n      mflag = true;\n    } else {\n      mflag = false;\n    }\n\n    var fs = f(s);\n\n    d = c;\n    c = b;\n\n    if (fa * fs < 0) {\n      b = s;\n    } else {\n      a = s;\n    }\n\n    if (Math.abs(fa) < Math.abs(fb)) {\n      // Swap a,b\n      var _temp = a;a = b;b = _temp;\n    }\n\n    if (fb === 0) {\n      return b;\n    }\n    if (fs === 0) {\n      return s;\n    }\n\n    if (Math.abs(a - b) <= δ) {\n      return b;\n    }\n\n    fa = f(a);\n    fb = f(b);\n  }\n}\n\nmodule.exports = rootOperators;\n\n},{\"./core-operators.js\":3}]},{},[1])(1)\n});"]}