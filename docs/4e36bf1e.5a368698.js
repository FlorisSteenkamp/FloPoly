(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{120:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return a})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return p}));var r=n(2),o=n(6),i=(n(0),n(231)),a={id:"roots_certified_all_roots_certified",title:"all-roots-certified"},l={unversionedId:"modules/roots_certified_all_roots_certified",id:"modules/roots_certified_all_roots_certified",isDocsHomePage:!1,title:"all-roots-certified",description:"\u25b8 function allRootsCertified",source:"@site/docs\\modules\\roots_certified_all_roots_certified.mdx",slug:"/modules/roots_certified_all_roots_certified",permalink:"/FloPoly/docs/modules/roots_certified_all_roots_certified",version:"current",sidebar:"sidebar",previous:{title:"random",permalink:"/FloPoly/docs/modules/predictive_random_double_random"},next:{title:"all-roots-certified-simplified",permalink:"/FloPoly/docs/modules/roots_certified_all_roots_certified_simplified"}},c=[],b={rightToc:c};function p(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(i.b)("wrapper",Object(r.a)({},b,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"\u25b8 function allRootsCertified\n(",Object(i.b)("inlineCode",{parentName:"p"},"p"),": number","[][]",", ",Object(i.b)("inlineCode",{parentName:"p"},"lb?"),": number, ",Object(i.b)("inlineCode",{parentName:"p"},"ub?"),": number, ",Object(i.b)("inlineCode",{parentName:"p"},"pE?"),": number[], ",Object(i.b)("inlineCode",{parentName:"p"},"getPExact?"),": function): ",Object(i.b)("a",{parentName:"p",href:"/FloPoly/docs/modules/roots_certified_root_interval#rootinterval"},"RootInterval"),"[]"),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},"Defined in ",Object(i.b)("a",{parentName:"em",href:"https://github.com/FlorisSteenkamp/FloPoly/blob/93f3a8d/src/roots/certified/all-roots-certified.ts#L185"},"roots/certified/all-roots-certified.ts:185"))),Object(i.b)("p",null,"Finds and returns all ",Object(i.b)("em",{parentName:"p"},"certified")," root intervals (bar underflow / overflow)\nof the given polynomial (with coefficients given in double-double precision\n(use ",Object(i.b)("a",{parentName:"p",href:"/FloPoly/docs/modules/roots_certified_all_roots_certified_simplified#allrootscertifiedsimplified"},"allRootsCertifiedSimplified")," if you only require coefficients in double\nprecision (the usual case))), including their multiplicities (see points below)."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"returns an empty array for a constant or the zero polynomial")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Let ",Object(i.b)("inlineCode",{parentName:"p"},"W = m * Number.EPSILON * max(1, 2^\u2308log\u2082r\u2309)"),", where"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"r")," is a root"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"m")," is the number of roots (the 'multiplicity') within the\ninterval, where multiplicity here includes roots seperated by less than\n",Object(i.b)("inlineCode",{parentName:"li"},"2*Number.EPSILON")," and not necessarily only exact multiple roots;"))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"the returned intervals are of max width ",Object(i.b)("inlineCode",{parentName:"p"},"W")," - use ",Object(i.b)("a",{parentName:"p",href:"/FloPoly/docs/modules/roots_certified_refine_k1#refinek1"},"refineK1")," to\nreduce the root interval widths further and thus 'resolving' the roots if\nrequired (although the roots are already ",Object(i.b)("em",{parentName:"p"},"guaranteed")," extremely accurate!)")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"the retuned root intervals will contain ",Object(i.b)("em",{parentName:"p"},"all")," roots hence the ",Object(i.b)("em",{parentName:"p"},"certified"),"\nin the function name.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"the reported multiplicities will be correct ",Object(i.b)("em",{parentName:"p"},"up to a multiple of 2")," in cases\nwhere ",Object(i.b)("em",{parentName:"p"},"more")," than 1 root is reported in the interval ",Object(i.b)("inlineCode",{parentName:"p"},"W")," described above\n(else if a multiplicity of 0 or 1 is reported the result is correct)")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("a",{parentName:"p",href:"/FloPoly/docs/modules/roots_certified_refine_k1#refinek1"},"refineK1")," can then be used to resolve them further; note however\nthat root seperation is a function of polynomial height and can be very small\n(see e.g. ",Object(i.b)("a",{parentName:"p",href:"https://hal.inria.fr/hal-01456686/document"},"Improving Root Separation Bounds, ",Object(i.b)("em",{parentName:"a"},"Aaron Herman, Hoon Hong, Elias Tsigaridas")))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"optimized for polynomials of degree 1 to about 30"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"this is due to ",Object(i.b)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Rolle%27s_theorem"},"Rolle's Theorem"),"\nbeing used and not ",Object(i.b)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Descartes%27_rule_of_signs"},"Descartes' rule of signs")),Object(i.b)("li",{parentName:"ul"},"Descartes' methods are asymptotically faster and thus better suited for higher\ndegree polynomials but for lower degrees Rolle's Theorem seems to be faster"))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"precondition:")," the coefficient magnitudes and degree of the polynomial\nmust be such that overflow won't occur at evaluation points where roots\nare searched for, e.g. a 20th degree polynomial with coefficients of\nmagnitude around ",Object(i.b)("inlineCode",{parentName:"p"},"Number.MAX_SAFE_INTEGER (= 9007199254740991)")," evaluated at\n",Object(i.b)("inlineCode",{parentName:"p"},"x = 1000000")," will evaluate to about ",Object(i.b)("inlineCode",{parentName:"p"},"10^136")," (10 the the power of 136) which\nis way too small for overflow to occur, however when evaluated at ",Object(i.b)("inlineCode",{parentName:"p"},"x = 10^15"),"\noverflow will occur; to prevent this unlikely possibility (roots are\ntypically not that large in applications) limit the bounds ",Object(i.b)("inlineCode",{parentName:"p"},"lb")," and ",Object(i.b)("inlineCode",{parentName:"p"},"ub"),"\nwhere roots are to be searched for to the range of interest, i.e. don't set\nthem to infinity for automatic calculation"))),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"example"))," "),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-typescript"},"\n// ---------------------------------------------------------------\n// 1. a basic example of an order 11 polynomial (with 10 roots) --\n// ---------------------------------------------------------------\nconst p = [\n    3.033321234234234,\n    31.78342995971597,\n    -115.09145437671532,\n    -48.18962838294827,\n    241.04136127393173,\n    -26.63962334942254,\n    -81.82713958224285,\n    13.96128683321424,\n    7.3963444329341455,\n    -1.50733058206533,\n    -0.0015147128834111722\n];\n//console.log(toCasStr(p))\n// => 3.033321234234234*x^10 + 31.78342995971597*x^9 - 115.09145437671532*x^8 -\n//    48.18962838294827*x^7 + 241.04136127393173*x^6 - 26.63962334942254*x^5 -\n//    81.82713958224285*x^4 + 13.96128683321424*x^3 + 7.3963444329341455*x^2 -\n//    1.50733058206533*x - 0.0015147128834111722\n// function to convert a double precision number to double-double precision\n// (note that the 'low double' is zero since the coefficients are assumed exact)\nconst toDoubleDouble = c => [0,c];\nconst roots = allRootsCertified(\n    p.map(toDoubleDouble),\n    Number.NEGATIVE_INFINITY,\n    Number.POSITIVE_INFINITY\n);\n//console.log(roots);\n// => [\n//   { tS: -13.222221, tE: -13.222220999999996, multiplicity: 1 },\n//   { tS: -1.3498348570000003, tE: -1.3498348569999998, multiplicity: 1 },\n//   { tS: -0.4444777699999987, tE: -0.4444777699999985, multiplicity: 1 },\n//   { tS: -0.43554300000000135, tE: -0.4355430000000011, multiplicity: 1 },\n//   { tS: -0.001000000000000222, tE: -0.001, multiplicity: 1 },\n//   { tS: 0.22999999999999984, tE: 0.23000000000000007, multiplicity: 1 },\n//   { tS: 0.345347, tE: 0.34534700000000024, multiplicity: 1 },\n//   { tS: 0.5429999999999989, tE: 0.5429999999999993, multiplicity: 1 },\n//   { tS: 1.3221000000000016, tE: 1.322100000000002, multiplicity: 1 },\n//   { tS: 2.534533999999997, tE: 2.534533999999998, multiplicity: 1 }\n// ]\n//\n// note: the above could also be achieved by using `allRootsCertifiedSimplified`\n// as follows:\n// const rs = allRootsCertifiedSimplified(p);\nconst rs = allRootsCertifiedSimplified(p);\n\n// -----------------------------------------------------------------------\n// 2. the Wilkinson polynomial of degree 50 (an *extremely* hard case) --\n// see: https://en.wikipedia.org/wiki/Wilkinson%27s_polynomial\n// -----------------------------------------------------------------------\nconst _roots = [...Array(50+1).keys()].slice(1).map(c => [c]);  // => [1,2,3,...,50]\nconst { pDd: p, pE, getPExact } = eFromRoots(_roots);\n// => polynomial of degree 50 with double-double precision coefficients\n//    including coefficient-wise error bound polynomial and a function to\n//    return the exact polynomial with Shewchuk expansion coefficients\n//console.log(toCasStr(getPExact()));\n// => x^50 - 1275*x^49 + 791350*x^48 - 318622500*x^47 + 93570498490*x^46 -\n//    21366198225750*x^45 + 3949131291964600*x^44 - ...\nconst roots = allRootsCertified(p,0,51,pE,getPExact);\nconsole.log(roots);  // => [\n//  { tS: 1, tE: 1, multiplicity: 1 },\n//  { tS: 2, tE: 2, multiplicity: 1 },\n//  .\n//  .\n//  .\n//  { tS: 50, tE: 50, multiplicity: 1 }\n// ]\n//\n// ...thus roots are returned accurately.\n//\n// Note: Due to floating point overflow of the evaluation of a Wilkinson\n// polynomial of degree >= 58 evaluated at 59 the returned roots starts\n// getting inaccurate at this degree (i.e. >= 58).\n")),Object(i.b)("h4",{id:"parameters"},"Parameters:"),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",{parentName:"tr",align:null},"Name"),Object(i.b)("th",{parentName:"tr",align:null},"Type"),Object(i.b)("th",{parentName:"tr",align:null},"Default value"),Object(i.b)("th",{parentName:"tr",align:null},"Description"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},Object(i.b)("inlineCode",{parentName:"td"},"p")),Object(i.b)("td",{parentName:"tr",align:null},"number","[][]"),Object(i.b)("td",{parentName:"tr",align:null},"-"),Object(i.b)("td",{parentName:"tr",align:null},"a polynomial with coefficients given densely as an array of double-double precision floating point numbers (if only double precision coefficients are required then use ",Object(i.b)("a",{parentName:"td",href:"/FloPoly/docs/modules/roots_certified_all_roots_certified_simplified#allrootscertifiedsimplified"},"allRootsCertifiedSimplified")," instead) from highest to lowest power, e.g. ",Object(i.b)("inlineCode",{parentName:"td"},"[[0,5],[0,-3],[0,0]]")," represents the polynomial ",Object(i.b)("inlineCode",{parentName:"td"},"5x^2 - 3x"),"; if the coefficients are double precision (as opposed to double-double) then instead of passing ",Object(i.b)("inlineCode",{parentName:"td"},"p")," pass ",Object(i.b)("inlineCode",{parentName:"td"},"p.map(c => [0,c])")," - this will transform the coefficients to double-double precision")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},Object(i.b)("inlineCode",{parentName:"td"},"lb")),Object(i.b)("td",{parentName:"tr",align:null},"number"),Object(i.b)("td",{parentName:"tr",align:null},"0"),Object(i.b)("td",{parentName:"tr",align:null},"defaults to 0; lower bound of roots to be returned; ",Object(i.b)("inlineCode",{parentName:"td"},"Number.NEGATIVE_INFINITY")," may be given if there is no lower bound")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},Object(i.b)("inlineCode",{parentName:"td"},"ub")),Object(i.b)("td",{parentName:"tr",align:null},"number"),Object(i.b)("td",{parentName:"tr",align:null},"1"),Object(i.b)("td",{parentName:"tr",align:null},"defaults to 1; upper bound of roots to be returned; ",Object(i.b)("inlineCode",{parentName:"td"},"Number.POSITIVE_INFINITY")," may be given if there is no upper bound")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},Object(i.b)("inlineCode",{parentName:"td"},"pE")),Object(i.b)("td",{parentName:"tr",align:null},"number[]"),Object(i.b)("td",{parentName:"tr",align:null},"undefined"),Object(i.b)("td",{parentName:"tr",align:null},"defaults to ",Object(i.b)("inlineCode",{parentName:"td"},"undefined"),"; an error polynomial that provides a coefficientwise error bound on the input polynomial; all coefficients must be positive; if ",Object(i.b)("inlineCode",{parentName:"td"},"undefined "),"then the input polynomial will be assumed exact")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},Object(i.b)("inlineCode",{parentName:"td"},"getPExact")),Object(i.b)("td",{parentName:"tr",align:null},"() => number","[][]"),Object(i.b)("td",{parentName:"tr",align:null},"undefined"),Object(i.b)("td",{parentName:"tr",align:null},"defaults to ",Object(i.b)("inlineCode",{parentName:"td"},"undefined"),"; a function returning the exact polynomial (with coefficients given as Shewchuk expansions (see the example below)) - ",Object(i.b)("inlineCode",{parentName:"td"},"getPExact")," will ",Object(i.b)("em",{parentName:"td"},"only")," be called if required (and can thus be lazy loaded) when the error bounds are too high during calculation preventing certification of the root intervals; if ",Object(i.b)("inlineCode",{parentName:"td"},"undefined "),"then the input polynomial will be assumed exact")))),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns:")," ",Object(i.b)("a",{parentName:"p",href:"/FloPoly/docs/modules/roots_certified_root_interval#rootinterval"},"RootInterval"),"[]"))}p.isMDXComponent=!0},231:function(e,t,n){"use strict";n.d(t,"a",(function(){return s})),n.d(t,"b",(function(){return m}));var r=n(0),o=n.n(r);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var b=o.a.createContext({}),p=function(e){var t=o.a.useContext(b),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},s=function(e){var t=p(e.components);return o.a.createElement(b.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},u=o.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,a=e.parentName,b=c(e,["components","mdxType","originalType","parentName"]),s=p(n),u=r,m=s["".concat(a,".").concat(u)]||s[u]||d[u]||i;return n?o.a.createElement(m,l(l({ref:t},b),{},{components:n})):o.a.createElement(m,l({ref:t},b))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,a=new Array(i);a[0]=u;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:r,a[1]=l;for(var b=2;b<i;b++)a[b]=n[b];return o.a.createElement.apply(null,a)}return o.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);