{"version":3,"sources":["flo-poly.min.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","FloPoly","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","allRootsRecursive","p","b","clip0","undefined","INF","d","rangeFilter","inRange","quadraticRoots","filter","lowerBound","upperBound","negativeRootLowerBound_LMQ","positiveRootUpperBound_LMQ","dp","differentiate","roots","unshift","push","rootsWithin","x","intervals","peval","evaluate","prevRoot","root","evA","evB","brent","coreOperators","rootOperators","rootBounds","toCasStr","rootMagnitudeUpperBound_fujiwara","positiveRootLowerBound_LMQ","negativeRootUpperBound_LMQ","Number","POSITIVE_INFINITY","./core-operators.js","./root-bounds.js","./root-operators.js","2","equal","p1","p2","add","d1","d2","Δd","Δd1","Δd2","Math","max","result","c1","c2","subtract","negate","multiplyByConst","multiply","Array","fill","j","c","degree","evaluateAt0","signChanges","prevSign","sign","deflate","bs","invert","slice","reverse","changeVariables","_i","res","_i2","_j","acc","reflectAboutYAxis","sturmChain","m","pnext","shift","clip","δ","EPSILON","maxCoefficient","abs","p_","str","cStr","toString","3","conditionNumber","pow","hornerErrorBound","errorAnalysis","4","random","fromRoots","Object","assign","allRoots","./all-roots-recursive.js","./error-analysis.js","./from-roots.js","./random.js","5","_require","6","predictiveRandom","seed","RANGE","randomArray","odds","SEED","vs","values","flatRoots","randArr","flatCoefficients","createArrFunction","v","flatRootsArr","flatCoefficientsArr","7","maxAbs","ns","apply","map","rootMagnitudeUpperBound_rouche","an","deg","timesUsed","ub","tempub","any","k","powres","POWERS","temp","8","_p","_slicedToArray","delta","sqrt","root1","root2","numRootsWithin","ps","as","bisection","_ref","fa","fb","fc","mflag","fac","fab","fbc","t1","b_c","s_b","c_d","fs","_temp","sliceIterator","arr","_arr","_n","_d","_e","_s","Symbol","iterator","next","done","value","err","isArray","TypeError"],"mappings":"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","file":"flo-poly.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.FloPoly = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nvar coreOperators = require('./core-operators.js');\nvar rootOperators = require('./root-operators.js');\nvar rootBounds = require('./root-bounds.js');\n\nvar brent = rootOperators.brent,\n    quadraticRoots = rootOperators.quadraticRoots;\nvar clip0 = coreOperators.clip0,\n    evaluate = coreOperators.evaluate,\n    differentiate = coreOperators.differentiate,\n    toCasStr = coreOperators.toCasStr;\nvar rootMagnitudeUpperBound_fujiwara = rootBounds.rootMagnitudeUpperBound_fujiwara,\n    positiveRootUpperBound_LMQ = rootBounds.positiveRootUpperBound_LMQ,\n    positiveRootLowerBound_LMQ = rootBounds.positiveRootLowerBound_LMQ,\n    negativeRootUpperBound_LMQ = rootBounds.negativeRootUpperBound_LMQ,\n    negativeRootLowerBound_LMQ = rootBounds.negativeRootLowerBound_LMQ;\n\n\nvar INF = Number.POSITIVE_INFINITY;\n\n/**\r\n * <p>Finds a near optimal approximation to the real roots (or those \r\n * within a range) of the input polynomial.\r\n * </p>\r\n * <p>\r\n * Only multiple roots of even order that is very close together may be \r\n * missed. (This is rarely a problem in practice - in a geometrical \r\n * application, for instance, this may mean two objects are barely \r\n * touching and returning either, all, or none of the repeated even \r\n * roots should not break the algorithm). \r\n * </p>\r\n * \r\n * @alias allRoots\r\n * @param {number[]} p - The polynomial\r\n * @param {number} a - Lower limit of root values that should be \r\n * returned - defaults to -∞\r\n * @param {number} b - Upper limit of root values that should be \r\n * returned - defaults to +∞\r\n * @returns {number[]} The found roots.\r\n * @impl_notes\r\n * @example\r\n * FloPoly.allRoots([1, -10, 35, -50, 24]); //=> [1, 2.0000000000000036, 3.0000000000000067, 4] \r\n */\nfunction allRootsRecursive(p, a, b) {\n\tp = clip0(p);\n\ta = a === undefined ? -INF : a;\n\tb = b === undefined ? +INF : b;\n\n\tvar d = p.length - 1;\n\tvar rangeFilter = inRange(a, b);\n\n\tif (d === 2) {\n\t\treturn quadraticRoots(p).filter(rangeFilter);\n\t\t// Investigate if any numerically stable algorithm could be as fast\n\t\t// as this algorithm (i.e by finding cubic roots within quadratic\n\t\t// root demarcated intervals via Brent's method. The cubicRoots \n\t\t// algoritm below has been removed since it was numerically \n\t\t// unstable.\n\t\t/*} else if (d === 3) {\r\n  \treturn cubicRoots(p)\r\n  \t\t.filter(rangeFilter)\r\n  \t\t.sort((a,b) => a-b)\r\n  } else if (d > 3) {*/\n\t} else if (d > 2) {\n\t\t// TODO The root bounding function below might have an impact on \n\t\t// performance - it would probably be better to use \n\t\t// positiveRootUpperBound_LMQ or (possibly) even better, the \n\t\t// linear version of it (see paper of Viglas, Akritas and \n\t\t// Strzebonski) and re-calculate bounds on every iteration.\n\t\tvar lowerBound = void 0;\n\t\tvar upperBound = void 0;\n\t\tif (a === -INF || b === +INF) {\n\t\t\t//let magnitudeBound = rootMagnitudeUpperBound_fujiwara(p);\n\t\t\t//lowerBound = a === -INF ? -magnitudeBound : a;\n\t\t\t//upperBound = b === +INF ? +magnitudeBound : b;\n\n\t\t\tif (a === -INF) {\n\t\t\t\tlowerBound = negativeRootLowerBound_LMQ(p);\n\t\t\t} else {\n\t\t\t\tlowerBound = a;\n\t\t\t}\n\t\t\tif (b === +INF) {\n\t\t\t\tupperBound = positiveRootUpperBound_LMQ(p);\n\t\t\t} else {\n\t\t\t\tupperBound = b;\n\t\t\t}\n\t\t} else {\n\t\t\tlowerBound = a;\n\t\t\tupperBound = b;\n\t\t}\n\n\t\t// If the roots of the differentiated polynomial is out of range \n\t\t// then the roots of the polynomial itself will also be out of \n\t\t// range.\n\t\tvar dp = differentiate(p);\n\t\tvar roots = allRootsRecursive(dp, lowerBound, upperBound).filter(rangeFilter);\n\n\t\tif (roots[0] !== lowerBound) {\n\t\t\t// For code coverage to cover the 'else' case we would need\n\t\t\t// to find a case where the lower bound actually matches the\n\t\t\t// root which would be very rare - needs further \n\t\t\t// investigation.\n\n\t\t\t// Not an actual root.\n\t\t\troots.unshift(lowerBound);\n\t\t}\n\t\tif (roots[roots.length - 1] !== upperBound) {\n\t\t\t// Not an actual root.\n\t\t\troots.push(upperBound);\n\t\t}\n\t\treturn rootsWithin(p, roots);\n\t} else if (d === 1) {\n\t\t// Less likely so put near bottom (micro optimization)\n\t\treturn [-p[1] / p[0]].filter(rangeFilter);\n\t} else if (d === 0) {\n\t\treturn []; // y = c -> no roots\t\n\t}\n\n\t// Least likely so put at bottom (micro optimization)\n\t// d === -1\n\t// y = 0 -> infinite number of roots\n\treturn [];\n}\n\n/**\r\n * Returns a function that returns true if x is in the range [a,b].\r\n *  \r\n * @ignore\r\n * @param {number} a\r\n * @param {number} b\r\n * @returns {function}\r\n */\nfunction inRange(a, b) {\n\treturn function (x) {\n\t\treturn x >= a && x <= b;\n\t};\n}\n\n/**\r\n * Finds all roots of the given polynomial within the given intervals.\r\n *  \r\n * @ignore\r\n * @param {number[]} p\r\n * @param {number[]} intervals\r\n * @returns {number[]} The found roots.\r\n */\nfunction rootsWithin(p, intervals) {\n\n\tvar roots = [];\n\tvar peval = evaluate(p);\n\n\tvar prevRoot = void 0;\n\tvar a = intervals[0];\n\tfor (var i = 1; i < intervals.length; i++) {\n\t\tvar root = void 0;\n\t\tvar b = intervals[i];\n\n\t\tvar evA = peval(a);\n\t\tvar evB = peval(b);\n\n\t\tvar k = evA * evB;\n\n\t\tif (k === 0) {\n\t\t\tif (evA === 0) {\n\t\t\t\troot = a;\n\t\t\t} else if (evB === 0 && i === intervals.length - 1) {\n\t\t\t\troot = b;\n\t\t\t}\n\t\t} else if (evA * evB < 0) {\n\t\t\troot = brent(peval, a, b);\n\t\t}\n\n\t\t// Add root if it exists and suppress exact duplicates\n\t\tif (root !== undefined && root !== prevRoot) {\n\t\t\troots.push(root);\n\t\t\tprevRoot = root;\n\t\t}\n\n\t\ta = b;\n\t}\n\n\treturn roots;\n}\n\nmodule.exports = allRootsRecursive;\n\n},{\"./core-operators.js\":2,\"./root-bounds.js\":7,\"./root-operators.js\":8}],2:[function(require,module,exports){\n'use strict';\n\nvar coreOperators = {\n\tequal: equal,\n\tadd: add,\n\tsubtract: subtract,\n\tmultiplyByConst: multiplyByConst,\n\tnegate: negate,\n\tdifferentiate: differentiate,\n\tmultiply: multiply,\n\tdegree: degree,\n\tevaluate: evaluate,\n\tevaluateAt0: evaluateAt0,\n\tsignChanges: signChanges,\n\tinvert: invert,\n\tchangeVariables: changeVariables,\n\treflectAboutYAxis: reflectAboutYAxis,\n\tsturmChain: sturmChain,\n\tclip: clip,\n\tclip0: clip0,\n\tdeflate: deflate,\n\tmaxCoefficient: maxCoefficient,\n\ttoCasStr: toCasStr\n\n\t/**\r\n  * Returns true if two polynomials are exactly equal by comparing \r\n  * coefficients.\r\n  * \r\n  * @param {number[]} p1 - A polynomial\r\n  * @param {number[]} p2 - Another polynomial \r\n  * @returns {boolean} True if exactly equal, false otherwise.\r\n  * @example\r\n  * FloPoly.equal([1,2,3,4], [1,2,3,4]);   //=> true\r\n  * FloPoly.equal([1,2,3,4], [1,2,3,4,5]); //=> false\r\n  */\n};function equal(p1, p2) {\n\tif (p1.length !== p2.length) {\n\t\treturn false;\n\t}\n\tfor (var i = 0; i < p1.length; i++) {\n\t\tif (p1[i] !== p2[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\r\n * Adds two polynomials.\r\n * \r\n * @param {number[]} p1 - The first polynomial\r\n * @param {number[]} p2 - The second polynomial\r\n * @returns {number[]} p1 + p2.\r\n * @example\r\n * FloPoly.add([1,2,3],[3,4]); //=> [1,5,7]\r\n */\nfunction add(p1, p2) {\n\t// Initialize result array  \n\tvar d1 = p1.length - 1;\n\tvar d2 = p2.length - 1;\n\tvar Δd = d1 - d2;\n\n\tvar Δd1 = 0;\n\tvar Δd2 = 0;\n\tif (Δd > 0) {\n\t\tΔd2 = -Δd;\n\t} else if (Δd < 0) {\n\t\tΔd1 = +Δd;\n\t}\n\n\tvar d = Math.max(d1, d2);\n\n\t// Add coefficients\n\tvar result = [];\n\tfor (var i = 0; i < d + 1; i++) {\n\t\tvar c1 = p1[i + Δd1];\n\t\tvar c2 = p2[i + Δd2];\n\t\tresult.push((c1 || 0) + (c2 || 0));\n\t}\n\n\t// Ensure the result is a valid polynomial representation\n\treturn clip0(result);\n}\n\n/** \r\n * Subtracts the second polynomial from first.\r\n * \r\n * @param {number[]} p1 - The polynomial from which will be subtracted\r\n * @param {number[]} p2 - The polynomial that will be subtracted\r\n * @returns {number[]} p1 - p2\r\n * @example\r\n * FloPoly.subtract([2,3],[4,4]); //=> [-2, -1]\r\n */\nfunction subtract(p1, p2) {\n\t// Initialize result array  \n\tvar d1 = p1.length - 1;\n\tvar d2 = p2.length - 1;\n\tvar Δd = d1 - d2;\n\n\tvar Δd1 = 0;\n\tvar Δd2 = 0;\n\tif (Δd > 0) {\n\t\tΔd2 = -Δd;\n\t} else if (Δd < 0) {\n\t\tΔd1 = +Δd;\n\t}\n\n\tvar d = Math.max(d1, d2);\n\n\t// Add coefficients\n\tvar result = [];\n\tfor (var i = 0; i < d + 1; i++) {\n\t\tvar c1 = p1[i + Δd1];\n\t\tvar c2 = p2[i + Δd2];\n\t\tresult.push((c1 || 0) - (c2 || 0));\n\t}\n\n\t// Ensure the result is a valid polynomial representation\n\treturn clip0(result);\n}\n\n/**\r\n * Negate the given polynomial (p -> -p).  \r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number[]} -p\r\n * @example\r\n * FloPoly.negate([0.1, -0.2]); //=> [-0.1, 0.2]\r\n */\nfunction negate(p) {\n\treturn multiplyByConst(-1, p);\n}\n\n/**  \r\n * Differentiates the given polynomial.\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number[]} D(p)\r\n * @example\r\n * FloPoly.differentiate([5, 4, 3, 2, 1]); //=> [20, 12, 6, 2]\r\n */\nfunction differentiate(p) {\n\n\tvar result = [];\n\n\tvar d = p.length - 1;\n\tfor (var i = 0; i < d; i++) {\n\t\tresult.push((d - i) * p[i]);\n\t}\n\n\treturn result;\n}\n\n/**\r\n * <p> \r\n * Multiplies the two given polynomials and returns the result. \r\n * </p>\r\n * <p>\r\n * See <a href=\"https://en.wikipedia.org/wiki/Polynomial_arithmetic\">polynomial arithmetic</a>\r\n * </p>\r\n * <p>\r\n * See <a href=\"https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Polynomial_multiplication\">polynomial multiplication</a>\r\n * </p>\r\n * <p>\r\n * See <a herf=\"http://web.cs.iastate.edu/~cs577/handouts/polymultiply.pdf\">polynomial multiplication (pdf)</a>\r\n * </p>\r\n * @param {number[]} p1 - The one polynomial.\r\n * @param {number[]} p2 - The other polynomial.\r\n * @returns {number[]} p1 * p2\r\n * @example\r\n * FloPoly.multiply([1,2,3], [2,5,3,5]); //=> [2, 9, 19, 26, 19, 15]\r\n */\n// TODO Currently using O(n^2) algorithm - possibly change to a faster  \n// FFT algorithm for high degree polynomials? No, we are interested in\n// polynomials of degree 20 or lower.\nfunction multiply(p1, p2) {\n\tvar d1 = p1.length - 1;\n\tvar d2 = p2.length - 1;\n\tvar d = d1 + d2;\n\n\tvar result = new Array(d + 1).fill(0);\n\tfor (var i = 0; i < d1 + 1; i++) {\n\t\tfor (var j = 0; j < d2 + 1; j++) {\n\t\t\tresult[d - (i + j)] += p1[d1 - i] * p2[d2 - j];\n\t\t}\n\t}\n\n\treturn clip0(result);\n}\n\n/** \r\n * Multiplies 2 polynomials by a constant.\r\n * \r\n * @param {number} c - The constant\r\n * @param {number[]} p - The polynomial\r\n * @returns {number[]} c*p\r\n * @example \r\n * FloPoly.multiplyByConst(0.25, [3,2,1]); //=> [0.75, 0.5, 0.25]  \r\n */\nfunction multiplyByConst(c, p) {\n\tif (c === 0) {\n\t\treturn [];\n\t}\n\n\tvar d = p.length - 1;\n\tvar result = [];\n\tfor (var i = 0; i < d + 1; i++) {\n\t\tresult.push(c * p[i]);\n\t}\n\n\t// We have to clip due to possible floating point underflow\n\treturn clip0(result);\n}\n\n/** \r\n * Returns the degree of the polynomial.\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number} \r\n * @example \r\n * FloPoly.degree([9,8,7,6,5,4,3,2,1]); //=> 9\r\n */\nfunction degree(p) {\n\treturn p.length - 1;\n}\n\n/** \r\n * Evaluates a univariate polynomial using Horner's method. This \r\n * function is curried (see examples below).  \r\n * \r\n * @see https://en.wikipedia.org/wiki/Horner%27s_method\r\n * @param {number[]} p - The polynomial\r\n * @param {number} a - The value at which to evaluate the polynomial.\r\n * @returns {number|function} The result if both parameters are supplied\r\n * or a function with arity one if only the first parameter is supplied.\r\n * @example\r\n * let ev = FloPoly.evaluate([3,2,1]);\r\n * ev(1); // => 6\r\n * ev(2); // => 17\r\n * \t\t \r\n * FloPoly.evaluate([3,2,1], 1); // => 6\r\n * FloPoly.evaluate([3,2,1], 2); // => 17\r\n * \r\n * FloPoly.evaluate([3,2,1])(1); // => 6\r\n * FloPoly.evaluate([3,2,1])(2); // => 17\r\n */\nfunction evaluate(p, a) {\n\tfunction evaluate(a) {\n\t\t//if p.length === 0 { return 0; }\n\t\tvar result = p[0];\n\t\tfor (var i = 1; i < p.length; i++) {\n\t\t\tresult = p[i] + result * a;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// Curry the function\n\treturn a === undefined ? evaluate : evaluate(a);\n}\n\n/** \r\n * Evaluates the given polynomial at 0 - it is much faster than at an \r\n * arbitrary point. \r\n *  \r\n * @param {number[]} p - The polynomial\r\n * @returns {number}\r\n * @example\r\n * FloPoly.evaluateAt0([3,2,99]); //=> 99\r\n */\nfunction evaluateAt0(p) {\n\treturn p[p.length - 1];\n};\n\n/** \r\n * <p>\r\n * Returns the number of sign changes in the polynomial coefficents \r\n * when ordered in descending order; zeros are ignored.\r\n * </p>\r\n * <p>\r\n * Descartes' rule of signs states (quoted from Wikipedia):\r\n * \"if the terms of a polynomial are ordered by descending variable \r\n * exponent, then the number of positive roots of the polynomial is \r\n * either equal to the number of sign differences between consecutive \r\n * nonzero coefficients, or is less than it by an even number. Multiple \r\n * roots of the same value are counted separately.\"\r\n * </p>\r\n * @see https://en.wikipedia.org/wiki/Descartes%27_rule_of_signs\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number} The number of sign changes.\r\n * @example\r\n * FloPoly.signChanges([1,2,-3,0,0,3,-1]); //=> 3\r\n */\nfunction signChanges(p) {\n\tvar d = p.length - 1;\n\n\tvar result = 0;\n\tvar prevSign = Math.sign(p[0]);\n\tfor (var i = 1; i < d + 1; i++) {\n\t\tvar sign = Math.sign(p[i]);\n\n\t\tif (sign !== prevSign && sign !== 0) {\n\t\t\tresult++;\n\t\t\tprevSign = sign;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\r\n * Deflates the given polynomial by removing a factor (x - r), where\r\n * r is a root of the polynomial.\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @param {number} root - A pre-calculated root of the polynomial.\r\n * @returns {number[]} The deflated polynomial.\r\n * @example\r\n * // The polynomial x^3 - 5x^2 + 8x - 4 has a root at 1 and a double root at 2 \r\n * FloPoly.deflate([1, -5, 8, -4], 2); //=> [1, -3, 2] \r\n * FloPoly.deflate([1, -3, 2], 2);     //=> [1,-1] \r\n * FloPoly.deflate([1, -1], 1);        //=> [1]\r\n */\nfunction deflate(p, root) {\n\tvar d = p.length - 1;\n\tvar bs = [p[0]];\n\tfor (var i = 1; i < d; i++) {\n\t\tbs.push(p[i] + root * bs[i - 1]);\n\t}\n\n\treturn bs;\n}\n\n/**\r\n * Inverts the given polynomial by reversing the order of the \r\n * coefficients.\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number} p(x) -> x^deg(p) * p(1/x)\r\n * @example\r\n * FloPoly.invert([1,2,3,4]); // => [4,3,2,1]\r\n * FloPoly.invert([3,2,-5]);  // => [-5,2,3]\r\n */\nfunction invert(p) {\n\treturn p.slice().reverse();\n}\n\n/**\r\n * <p> \r\n * Performs a change of variables of the form: p(x) <- p(ax + b).\r\n * </p>\r\n * <p>\r\n * See <a href=\"http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system\">this stackoverflow question</a>\r\n * </p>\r\n * @param {number[]} p - The polynomial\r\n * @param {number} a\r\n * @param {number} b\r\n * @returns {number[]} The transformed polynomial.\r\n * @example\r\n * FloPoly.changeVariables([1,2,7], 3, 4); //=> [9, 30, 31]\r\n */\nfunction changeVariables(p, a, b) {\n\t// We let the coefficients of p(ax + b) be denoted by d_i in the \n\t// code below. \n\t// d_i is calculated as d = T*c, where c are the original \n\t// coefficients.\n\n\tvar d = p.length - 1;\n\n\t// Initialize a zero matrix\n\tvar t = [];\n\tfor (var i = 0; i < d + 1; i++) {\n\t\tt.push(new Array(d + 1).fill(0));\n\t}\n\n\t// Calculate the triangular matrix T\n\tt[0][0] = 1;\n\tfor (var j = 1; j <= d; j++) {\n\t\tt[0][j] = b * t[0][j - 1];\n\t\tfor (var _i = 1; _i <= j; _i++) {\n\t\t\tt[_i][j] = b * t[_i][j - 1] + a * t[_i - 1][j - 1];\n\t\t}\n\t}\n\n\t// Multiply\n\tvar res = new Array(d + 1).fill(0);\n\tfor (var _i2 = 0; _i2 <= d; _i2++) {\n\t\tres[d - _i2] = 0;\n\t\tfor (var _j = _i2; _j <= d; _j++) {\n\t\t\tvar acc = t[_i2][_j] * p[d - _j];\n\t\t\tres[d - _i2] += acc;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n/**\r\n * Reflects the given polynomial about the Y-axis, i.e. perform the \r\n * change of variables: p(x) <- p(-x).\r\n * \r\n * @param {number[]} p - The polynomial to reflect\r\n * @returns {number[]} The reflected polynomial.\r\n * @example\r\n * FloPoly.reflectAboutYAxis([5,4,3,2,1]); //=> [5, -4, 3, -2, 1]\r\n */\nfunction reflectAboutYAxis(p) {\n\tvar d = p.length - 1;\n\n\tvar result = p.slice();\n\tfor (var i = 0; i < d + 1; i++) {\n\t\tif (i % 2) {\n\t\t\tresult[i] = -result[i];\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/** \r\n * Generates a sturm chain for the given polynomial.\r\n * \r\n * @see https://en.wikipedia.org/wiki/Sturm%27s_theorem\r\n * @param {number[]} p - The polynomial\r\n * @returns {number[][]} The sturm chain of polynomials\r\n * @example\r\n * FloPoly.sturmChain([-3,4,2,-2]); //=> [[-3, 4, 2, -2], [-9, 8, 2], [-2.5185185185185186, 1.7037037037037037], [-3.2932525951557086]]\r\n */\nfunction sturmChain(p) {\n\n\t/** \r\n  * Returns the negative of the remainder when dividing the first \r\n  * polynomial (the dividend) by the second (the divisor) provided \r\n  * that deg(p1) - deg(p2) === 1.\r\n  * \r\n  * @ignore\r\n  * @param {number[]} p1 - The first polynomial (dividend)\r\n  * @param {number[]} p2 - The second polynomial (divisor)\r\n  * @see https://en.wikipedia.org/wiki/Sturm%27s_theorem\r\n  */\n\tfunction negRemainder(p1, p2) {\n\t\tvar d1 = p1.length - 1;\n\t\tvar d2 = p2.length - 1;\n\t\tvar d = d1 - d2;\n\n\t\tvar a = p1[1] / p1[0] - p2[1] / p2[0];\n\t\tvar b = p1[0] / p2[0];\n\n\t\tvar p3 = multiply(multiplyByConst(b, p2), [1, a]);\n\n\t\treturn subtract(p3, p1);\n\t}\n\n\tvar m = []; // Sturm chain\n\tm.push(p);\n\tm.push(differentiate(p));\n\n\t//const δ = 10 * Number.EPSILON;\n\tvar i = 1;\n\twhile (m[i].length - 1 > 0) {\n\t\tvar pnext = negRemainder(m[i - 1], m[i]);\n\t\t//pnext = clip(pnext, δ);\n\t\t// If the polynomial degree was not reduced due to roundoff\n\t\t// such that the first 1 or more terms are very small.\n\t\twhile (m[i].length - pnext.length < 1) {\n\t\t\tpnext.shift();\n\t\t}\n\t\t/*\r\n  if (pnext.length === 0) {\r\n  \tbreak;\r\n  }\r\n  */\n\t\tm.push(pnext);\n\n\t\ti++;\n\t}\n\n\treturn m;\n}\n\n/**\r\n * If the highest power coefficient is small in the sense that the \r\n * highest power term has a negligible contribution (compared to the\r\n * other terms) at x = 1 then clip() can be called to remove all such \r\n * highest terms. A contribution of less than Number.EPSILON of the \r\n * highest coefficient will be considered negligible by default.\r\n * \r\n * \r\n * @param {number[]} p - The polynomial to be clipped.\r\n * @param {number} δ - The optional contribution tolerence else \r\n *        Number.EPSILON will be used by default.   \r\n * @returns {number[]} The clipped polynomial.\r\n * @example\r\n * FloPoly.clip([1e-18, 1e-10, 1e-5]); //=> [1e-18, 1e-10, 1e-5] \r\n * FloPoly.clip([1e-18, 1e-10, 1e-1]); //=> [1e-10, 1e-1]\r\n */\nfunction clip(p, δ) {\n\tδ = δ === undefined ? Number.EPSILON : δ;\n\n\tvar c = maxCoefficient(p);\n\tif (c === 0) {\n\t\treturn [];\n\t}\n\n\tif (Math.abs(p[0]) > δ * c) {\n\t\treturn p;\n\t}\n\n\tvar p_ = p.slice(1);\n\twhile (Math.abs(p_[0]) < δ * c) {\n\t\tp_ = p_.slice(1);\n\t}\n\n\treturn clip(p_, δ);\n}\n\n/**\r\n * If the highest power coefficient is 0 then clip() can be called to \r\n * remove all such highest terms so that the array is a valid \r\n * presentation of a polynomial.\r\n * \r\n * @param {number[]} p - The polynomial to be clipped.\r\n * @returns {number[]} The clipped polynomial.\r\n * @example\r\n * FloPoly.clip0([1e-18, 1e-10, 1e-1]); //=> [1e-18, 1e-10, 1e-1]\r\n * FloPoly.clip0([0, 1e-10, 1e-1]); //=> [1e-10, 1e-1]\r\n */\nfunction clip0(p) {\n\treturn p[0] !== 0 ? p : clip0(p.slice(1));\n}\n\n/**\r\n * Returns the absolute value of the highest coefficient of the \r\n * polynomial.\r\n * \r\n * @param p {number[]} p - The polynomial.\r\n * @returns {number}\r\n * @example\r\n * FloPoly.maxCoefficient([-2, 0.1, 0.2]); //=> 2\r\n */\nfunction maxCoefficient(p) {\n\tvar max = 0;\n\tfor (var i = 0; i < p.length; i++) {\n\t\tvar c = Math.abs(p[i]);\n\t\tif (c > max) {\n\t\t\tmax = c;\n\t\t}\n\t}\n\n\treturn max;\n}\n\n/**\r\n * Returns a string representing the given polynomial that is readable \r\n * by a human or a CAS (Computer Algebra System).\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {string}\r\n * @example\r\n * FloPoly.toCasStr([5,4,3,2,1]); //=> \"x^4*5 + x^3*4 + x^2*3 + x*2 + 1\"\r\n */\nfunction toCasStr(p) {\n\tvar d = p.length - 1;\n\n\tvar str = '';\n\tfor (var i = 0; i < d + 1; i++) {\n\t\tvar cStr = p[i].toString();\n\t\tif (i === d) {\n\t\t\tstr += cStr;\n\t\t} else if (i === d - 1) {\n\t\t\tstr += 'x*' + cStr + ' + ';\n\t\t} else {\n\t\t\tstr += 'x^' + (d - i).toString() + '*' + cStr + ' + ';\n\t\t}\n\t}\n\n\treturn str;\n}\n\nmodule.exports = coreOperators;\n\n},{}],3:[function(require,module,exports){\n'use strict';\n\nvar coreOperators = require('./core-operators.js');\n\nvar errorAnalysis = {\n  hornerErrorBound: hornerErrorBound\n};\n\nvar evaluate = coreOperators.evaluate;\n\n/**\r\n * <p>\r\n * Approximate condition number for polynomial evaluation multiplied\r\n * by the exact value of the polynomial evaluation.\r\n * </p>\r\n * <p>\r\n * See <a href=\"http://www-pequan.lip6.fr/~jmc/polycopies/Compensation-horner.pdf\">Compensated Horner Scheme - paragraph 1.1</a>\r\n * </p>\r\n * \r\n * @ignore\r\n * @param {number[]} p - The polynomial\r\n * @param {number} x - The evaluation point\r\n * @returns {number} The condition number multiplied exact polynomial \r\n * value at x\r\n */\n\nfunction conditionNumber(p, x) {\n  var d = p.length - 1;\n  var res = 0;\n\n  for (var i = 0; i < d; i++) {\n    res += Math.abs(p[i] * Math.pow(x, d - i));\n  }\n\n  return res;\n}\n\n/**\r\n * <p>\r\n * Classic rule of thumb approximate error bound when using Horner's \r\n * method to evaluate polynomials. \r\n * </p>\r\n * <p>\r\n * See for instance <a href=\"http://www-pequan.lip6.fr/~jmc/polycopies/Compensation-horner.pdf\">compensated horner evaluation</a>\r\n * </p>\r\n * @param p {number[]} - The polynomial\r\n * @param x {number} - Value at which polynomial is evaluated. \r\n * @returns {number} The error bound\r\n * @example\r\n * hornerErrorBound([1.1,2.2,-3.3], 1.5); //=> 5.1292303737682235e-15 \r\n */\nfunction hornerErrorBound(p, x) {\n  var δ = Number.EPSILON;\n\n  var d = p.length - 1;\n  return 2 * d * δ * conditionNumber(p, x);\n}\n\nmodule.exports = errorAnalysis;\n\n},{\"./core-operators.js\":2}],4:[function(require,module,exports){\n'use strict';\n\nvar coreOperators = require('./core-operators.js');\nvar rootOperators = require('./root-operators.js');\nvar rootBounds = require('./root-bounds.js');\n//let allRootsVAS       = require('./all-roots-vas.js');\nvar allRootsRecursive = require('./all-roots-recursive.js');\nvar random = require('./random.js');\nvar errorAnalysis = require('./error-analysis.js');\nvar fromRoots = require('./from-roots.js');\n\nvar multiply = coreOperators.multiply;\n\n/**\r\n* <p>\r\n* Simple & fast practical library functions for functional univariate \r\n* polynomials over the reals (actually ECMAScript numbers, i.e. double \r\n* floats).\r\n* </p>\r\n* <p>\r\n* All polinomials are represented as a simple array starting with the \r\n* highest non-zero power, e.g. \r\n*   3x^3 + 5x^2 + 7x + 2 -> [3,5,7,2]\r\n* </p>\r\n* @ignore\r\n*/\nvar FloPoly = Object.assign({}, coreOperators, rootOperators, rootBounds, { random: random }, { fromRoots: fromRoots }, {\n\t\tallRoots: allRootsRecursive\n\t\t//allRootsVAS,\n}, errorAnalysis);\n\nmodule.exports = exports = FloPoly;\n\n},{\"./all-roots-recursive.js\":1,\"./core-operators.js\":2,\"./error-analysis.js\":3,\"./from-roots.js\":5,\"./random.js\":6,\"./root-bounds.js\":7,\"./root-operators.js\":8}],5:[function(require,module,exports){\n'use strict';\n\nvar _require = require('./core-operators.js'),\n    multiply = _require.multiply;\n\n/**\r\n * <p>\r\n * Constructs a polynomial from the given roots by multiplying out the \r\n * factors (x - root1)(x - root2)... Note that the resulting polynomial \r\n * will not have any complex roots.\r\n * </p>\r\n * <p>\r\n * Mostly provided for testing purposes. Note that the real roots of the \r\n * constructed polynomial may not be exactly the same as the roots that\r\n * the polynomial has been constructed from due to floating-point \r\n * round-off.\r\n * </p>\r\n * \r\n * @param {number[]} roots - The roots\r\n * @returns {number[]} The constructed polynomial.\r\n * @example\r\n * FloPoly.fromRoots([1,2,3,3]); //=> [1, -9, 29, -39, 18]\r\n * FloPoly.allRoots([1, -9, 29, -39, 18]); //=> [1.0000000000000007, 2.000000000000004]\r\n * // In the above note the rounding error. Also note the multiple root of 3 that has been missed but as stated previously this does not generally pose a problem for even multiple roots. See the examples below.\r\n * FloPoly.allRoots([1, -9, 29, -39, 17.99999999999999]); //=> [0.9999999999999973, 2.00000000000002, 2.9999999999999982]\r\n * FloPoly.allRoots([1, -9, 29, -39, 17.9999999999999]); //=> [0.999999999999975, 2.0000000000000986, 2.9999997898930832, 3.0000002095475775]\r\n */\n\n\nfunction fromRoots(roots) {\n  var p = [1];\n  for (var i = 0; i < roots.length; i++) {\n    p = multiply(p, [1, -roots[i]]);\n  }\n\n  return p;\n}\n\nmodule.exports = fromRoots;\n\n},{\"./core-operators.js\":2}],6:[function(require,module,exports){\n'use strict';\n\nvar fromRoots = require('./from-roots.js');\n\n/**\r\n * Some seed value for the simple random number generator.\r\n * @ignore\r\n */\nvar SEED = 123456789;\n\n/**\r\n * The range for the simple random number generator, i.e. the generated\r\n * numbers will be in [0,RANGE].\r\n * @ignore\r\n */\nvar RANGE = 4294967296;\n\n/**\r\n * Generates an array of random polynomials with parameters as specified \r\n * by flatRoots. The exact same polynomials will be created on each\r\n * call to this function if the same seed is used - this is by design to \r\n * improve testability.\r\n *   \r\n * @memberof random\r\n * @param {number} n - The number of polynomials to generate.\r\n * @param {number} d - The degree of the polynomials \r\n * @param {number} a - The lower bound of the distribution - defaults \r\n * to 0\r\n * @param {number} b - The upper bound of the distribution - defaults \r\n * to 1\r\n * @param {number} seed - A seed value for generating random values (so\r\n * that the results are reproducable)\r\n * @param {number} odds - The odds that a root will be doubled (applied\r\n * recursively so that some roots will be tripled, etc. - defaults to 0\r\n * @returns {number[][]} The array of random polynomials.\r\n * @example\r\n * FloPoly.random.flatRootsArr(2,3,0,10); //=> [[1, -17.27247918024659, 97.33487287168995, -179.34094494147305], [1, -14.934967160224915, 57.624514485645406, -14.513933300587215]]\r\n * FloPoly.random.flatRootsArr(2,3,0,10); //=> [[1, -17.27247918024659, 97.33487287168995, -179.34094494147305], [1, -14.934967160224915, 57.624514485645406, -14.513933300587215]]\r\n */\nvar flatRootsArr = createArrFunction(flatRoots);\n\n/**\r\n * Generates an array of random polynomials as specified by \r\n * flatCoefficients. The exact same polynomials will be created on each\r\n * call to this function if the same seed is used - this is by design to \r\n * improve testability.\r\n *   \r\n * @memberof random\r\n * @param {number} n - The number of polynomials to generate.\r\n * @param {number} d - The degree of the polynomials \r\n * @param {number} a - The lower bound of the distribution - defaults \r\n * to 0\r\n * @param {number} b - The upper bound of the distribution - defaults \r\n * to 1\r\n * @param {number} seed - A seed value for generating random values (so\r\n * that the results are reproducable)\r\n * @returns {number[][]} The array of random polynomials.\r\n * @example\r\n * FloPoly.random.flatCoefficientsArr(2,3,-2,2); //=> [[0.1749166026711464, -0.20349335670471191, 0.9375684261322021], [1.0617692470550537, -1.8918039798736572, 0.8040215969085693]]\r\n * FloPoly.random.flatCoefficientsArr(2,3,-2,2); //=> [[0.1749166026711464, -0.20349335670471191, 0.9375684261322021], [1.0617692470550537, -1.8918039798736572, 0.8040215969085693]]\r\n */\nvar flatCoefficientsArr = createArrFunction(flatCoefficients);\n\nvar random = {\n  flatRoots: flatRoots,\n  flatRootsArr: flatRootsArr,\n  flatCoefficients: flatCoefficients,\n  flatCoefficientsArr: flatCoefficientsArr\n\n  /**\r\n   * https://stackoverflow.com/questions/3062746/special-simple-random-number-generator\r\n   * \r\n   * @ignore\r\n   * @param {number} seed\r\n   * @returns {number} A quasi-random number to be used as the next input \r\n   * to this function.\r\n   */\n};function predictiveRandom(seed) {\n  var a = 134775813;\n\n  return (a * seed + 1) % RANGE;\n}\n\n/**\r\n * Generates a random array of numbers picked from a bounded flat \r\n * distribution (i.e. a rectangular distribution) with specified odds of \r\n * duplication of consecutive values.\r\n *   \r\n * @ignore\r\n * @param {number} n - The number of values to generate.\r\n * @param {number} a - The lower bound of the distribution - defaults \r\n * to 0\r\n * @param {number} b - The upper bound of the distribution - defaults \r\n * to 1\r\n * @param {number} seed - A seed value for generating random values (so\r\n * that the results are reproducable)\r\n * @param {number} odds - The odds that a root will be doubled (applied\r\n * recursively so that some roots will be tripled, etc. - defaults to 0\r\n * @returns {number[]} - The random array.\r\n */\nfunction randomArray(n, a, b, seed, odds) {\n  seed = seed === undefined ? SEED : seed;\n  odds = odds === undefined ? 0 : odds;\n\n  var vs = [];\n  for (var i = 0; i < n; i++) {\n    seed = predictiveRandom(seed);\n    var v = seed / RANGE * (b - a) + a;\n    seed = push(seed, vs, v, odds);\n  }\n  vs = vs.slice(0, n);\n\n  return { vs: vs, seed: seed };\n}\n\n/**\r\n * Helper function that will add more numbers to the passed array - \r\n * modifies the values parameter.\r\n *\r\n * @ignore\r\n * @param {number[]} values - An existing array of values - will be \r\n * modified!\r\n * @param {number} x - The number that will be added (possibly\r\n * multiple times)\r\n * @param {number} odds - The odds that the number will be added\r\n * again (recursively). \r\n */\nfunction push(seed, values, x, odds) {\n  seed = predictiveRandom(seed);\n\n  values.push(x);\n  if (seed / RANGE < odds) {\n    seed = push(seed, values, x, odds);\n  }\n\n  return seed;\n}\n\n/**\r\n * Generates a random polynomial with roots picked from a bounded flat \r\n * distribution (i.e. a rectangular distribution) with specified odds of \r\n * duplication of consecutive values. Note that the resulting polynomial\r\n * won't have any complex roots.\r\n * \r\n * @memberof random\r\n * @param {number} d - The degree of the polynomials \r\n * @param {number} a - The lower bound of the distribution - defaults \r\n * to 0\r\n * @param {number} b - The upper bound of the distribution - defaults \r\n * to 1\r\n * @param {number} seed - A seed value for generating random values (so\r\n * that the results are reproducable)\r\n * @param {number} odds - The odds that a root will be doubled (applied\r\n * recursively so that some roots will be tripled, etc. - defaults to 0\r\n * @returns {{p: number[], seed: number}} a random polynomial and the\r\n * last seed value to reuse.\r\n * @example\r\n * FloPoly.random.flatRoots(3,0,10); //=> { p: [1, -17.27247918024659, 97.33487287168995, -179.34094494147305], seed: 939629312 }\r\n */\nfunction flatRoots(d, a, b, seed, odds) {\n  a = a === undefined ? 0 : a;\n  b = b === undefined ? 1 : b;\n  seed = seed === undefined ? SEED : seed;\n  odds = odds === undefined ? 0 : odds;\n\n  var randArr = randomArray(d, a, b, seed, odds);\n  seed = randArr.seed;\n\n  var p = fromRoots(randArr.vs);\n\n  return { p: p, seed: seed };\n}\n\n/**\r\n * Generates a random polynomial with coefficients picked from a bounded \r\n * flat distribution (i.e. a rectangular distribution). \r\n * \r\n * @memberof random\r\n * @param {number} d - The degree of the polynomials \r\n * @param {number} a - The lower bound of the distribution - defaults \r\n * to -1\r\n * @param {number} b - The upper bound of the distribution - defaults \r\n * to 1\r\n * @param {number} seed - A seed value for generating random values (so\r\n * that the results are reproducable)\r\n * @returns {{p: number[], seed: number}} a random polynomial and the\r\n * last seed value to reuse.\r\n * @example\r\n * FloPoly.random.flatCoefficients(3,-5,5); //=> { p: [0.437291506677866, -0.5087333917617798, 2.3439210653305054], seed: 939629312 }\r\n */\nfunction flatCoefficients(d, a, b, seed) {\n  a = a === undefined ? -1 : a;\n  b = b === undefined ? +1 : b;\n  seed = seed === undefined ? SEED : seed;\n\n  var randArr = randomArray(d, a, b, seed);\n  seed = randArr.seed;\n\n  var p = randArr.vs;\n\n  return { p: p, seed: seed };\n}\n\n/**\r\n * Creates a function from the given function with parameters similar\r\n * to flatRoots but with an extra parameter in the beginning indicating\r\n * the length of the array generated by the original function.\r\n * \r\n * @ignore\r\n * @param {function} f\r\n * @returns {function}\r\n */\nfunction createArrFunction(f) {\n  return function (n, d, a, b, seed, odds) {\n    seed = seed === undefined ? SEED : seed;\n    var res = [];\n\n    for (var i = 0; i < n; i++) {\n      var v = f(d, a, b, seed, odds);\n      var p = v.p;\n      seed = v.seed;\n\n      res.push(p);\n    }\n\n    return res;\n  };\n}\n\nmodule.exports = random;\n\n},{\"./from-roots.js\":5}],7:[function(require,module,exports){\n'use strict';\n\nvar coreOperators = require('./core-operators.js');\n\nvar invert = coreOperators.invert,\n    negate = coreOperators.negate,\n    reflectAboutYAxis = coreOperators.reflectAboutYAxis;\n\n\nvar rootBounds = {\n\trootMagnitudeUpperBound_fujiwara: rootMagnitudeUpperBound_fujiwara,\n\tpositiveRootUpperBound_LMQ: positiveRootUpperBound_LMQ,\n\tpositiveRootLowerBound_LMQ: positiveRootLowerBound_LMQ,\n\tnegativeRootUpperBound_LMQ: negativeRootUpperBound_LMQ,\n\tnegativeRootLowerBound_LMQ: negativeRootLowerBound_LMQ,\n\trootMagnitudeUpperBound_rouche: rootMagnitudeUpperBound_rouche\n\n\t/**\r\n  * Returns the maximum magnitude value within the supplied array of \r\n  * numbers.\r\n  * @ignore \r\n  */\n};function maxAbs(ns) {\n\treturn Math.max.apply(null, ns.map(function (n) {\n\t\treturn Math.abs(n);\n\t}));\n}\n\n/**\r\n * Finds an upper bound on the magnitude (absolute value) of the roots\r\n * (including complex roots) of the given polynomial using Rouche's \r\n * Theorem with k = n. This function is fast but the bound is not tight.\r\n * \r\n * @param p {number[]} p - The polynomial.\r\n * @returns {number} The bound.\r\n */\nfunction rootMagnitudeUpperBound_rouche(p) {\n\tvar d = p.length - 1;\n\tvar R = 1 + 1 / p[0] * maxAbs(p.slice(1));\n\treturn R;\n}\n\n/**\r\n * Finds an upper bound on the magnitude (absolute value) of the roots\r\n * of the given polynomial using the near-optimal Fujiwara bound. Note\r\n * that the bound includes complex roots. The bound is tight but slow \r\n * due to usage of Math.pow().\r\n * \r\n * @see https://en.wikipedia.org/wiki/Properties_of_polynomial_roots#cite_note-Fujiwara1916-4\r\n * \r\n * @param {number[]} p - The polynomial.\r\n * @returns {number} The bound.\r\n * @example\r\n * FloPoly.rootMagnitudeUpperBound_fujiwara([2,-3,6,5,-130]); //=> 6.753296750770361\r\n * FloPoly.allRoots([2,-3,6,5,-130]); //=> [-2.397918624065303, 2.8793785310848383]\r\n */\nfunction rootMagnitudeUpperBound_fujiwara(p) {\n\tvar d = p.length - 1;\n\n\tvar an = p[0];\n\tvar bs = [];\n\n\tfor (var i = 1; i < d; i++) {\n\t\tvar b = Math.pow(Math.abs(p[i] / an), 1 / i);\n\t\tbs.push(b);\n\t}\n\n\tbs.push(Math.pow(Math.abs(p[d] / 2 * an), 1 / d));\n\n\treturn 2 * Math.max.apply(undefined, bs);\n}\n\nvar POWERS = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152];\n/**\r\n * <p> \r\n * Returns an upper bound for the positive real roots of the given \r\n * polynomial.\r\n * </p>\r\n * <p>\r\n * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński, \r\n * specifically the LocalMaxQuadratic algorithm hence LMQ.\r\n * </p>  \r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number} A lower bound.\r\n * @example\r\n * FloPoly.positiveRootUpperBound_LMQ([2,-3,6,5,-130]); //=> 4.015534272870436 \r\n * FloPoly.positiveRootUpperBound_LMQ([2,3]);           //=> 0 \r\n * FloPoly.positiveRootUpperBound_LMQ([-2,-3,-4]);      //=> 0\r\n */\nfunction positiveRootUpperBound_LMQ(p) {\n\tvar deg = p.length - 1;\n\tif (deg < 1) {\n\t\treturn 0;\n\t}\n\n\tif (p[0] < 0) {\n\t\tp = negate(p);\n\t}\n\n\tvar timesUsed = [];\n\tfor (var i = 0; i < deg; i++) {\n\t\ttimesUsed.push(1);\n\t}\n\n\tvar ub = 0;\n\n\tfor (var m = 0; m <= deg; m++) {\n\t\tif (p[m] >= 0) continue;\n\n\t\tvar tempub = Number.POSITIVE_INFINITY;\n\t\tvar any = false;\n\n\t\tfor (var k = 0; k < m; k++) {\n\t\t\tif (p[k] <= 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Table lookup is about 70% faster but both are\n\t\t\t// extemely fast anyway. \n\t\t\t// Result is at https://www.measurethat.net/Benchmarks/ShowResult/6610\n\t\t\tvar pow = timesUsed[k];\n\t\t\tvar powres = void 0;\n\t\t\tif (pow > 20) {\n\t\t\t\tpowres = Math.pow(2, pow);\n\t\t\t} else {\n\t\t\t\tpowres = POWERS[pow];\n\t\t\t}\n\t\t\tvar temp = Math.pow(-p[m] / (p[k] / powres), 1 / (m - k));\n\n\t\t\ttimesUsed[k]++;\n\n\t\t\tif (tempub > temp) {\n\t\t\t\ttempub = temp;\n\t\t\t}\n\n\t\t\tany = true;\n\t\t}\n\n\t\tif (any && ub < tempub) ub = tempub;\n\t}\n\n\treturn ub;\n}\n\n/**\r\n * <p> \r\n * Calculates a lower bound for the positive roots of the given \r\n * polynomial.\r\n * </p>\r\n * <p>\r\n * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński, \r\n * specifically the LocalMaxQuadratic algorithm hence LMQ.\r\n * </p>\r\n *  \r\n * @param {number[]} p - The polynomial\r\n * @returns {number} A lower bound.\r\n * @example\r\n * FloPoly.positiveRootLowerBound_LMQ([2,-3,6,5,-130]); //=> 1.6883241876925903\r\n * FloPoly.positiveRootLowerBound_LMQ([2,3]);           //=> 0 \r\n * FloPoly.positiveRootLowerBound_LMQ([-2,-3,-4]);      //=> 0\r\n */\nfunction positiveRootLowerBound_LMQ(p) {\n\tvar ub = positiveRootUpperBound_LMQ(invert(p));\n\tif (ub === 0) {\n\t\treturn 0;\n\t}\n\treturn 1 / ub;\n}\n\n/**\r\n * See positiveRootUpperBound_LMQ\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number} An upper bound.\r\n */\nfunction negativeRootUpperBound_LMQ(p) {\n\treturn -positiveRootLowerBound_LMQ(reflectAboutYAxis(p));\n}\n\n/**\r\n * See positiveRootLowerBound_LMQ\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number} A lower bound.\r\n */\nfunction negativeRootLowerBound_LMQ(p) {\n\treturn -positiveRootUpperBound_LMQ(reflectAboutYAxis(p));\n}\n\nmodule.exports = rootBounds;\n\n},{\"./core-operators.js\":2}],8:[function(require,module,exports){\n'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar coreOperators = require('./core-operators.js');\n\n/**\r\n * Operators (i.e. functions) directly related to roots and root \r\n * finding. \r\n * \r\n * @ignore\r\n */\nvar rootOperators = {\n  quadraticRoots: quadraticRoots,\n  //cubicRoots,\n  numRootsWithin: numRootsWithin,\n  brent: brent,\n  bisection: bisection\n};\n\nvar sturmChain = coreOperators.sturmChain,\n    evaluate = coreOperators.evaluate,\n    signChanges = coreOperators.signChanges;\n\n/**\r\n * <p>\r\n * Floating-point-stably calculates and returns the ordered quadratic \r\n * roots of the given quadratic polynomial.\r\n * </p>\r\n * <p>\r\n * This function is included only because it might be slightly faster\r\n * than calling allRoots due to allRoots first checking if the \r\n * polynomial is quadratic and checking if the roots are within the\r\n * given range.\r\n * </p>\r\n * @param {number[]} p - The 2nd order polynomial\r\n * @returns {number[]} The found quadratic roots.\r\n * @example \r\n * FloPoly.quadraticRoots([1, -3, 2]); //=> [1,2]\r\n */\n\nfunction quadraticRoots(p) {\n  var _p = _slicedToArray(p, 3),\n      a = _p[0],\n      b = _p[1],\n      c = _p[2];\n\n  var delta = b * b - 4 * a * c;\n\n  if (delta < 0) {\n    // No real roots;\n    return [];\n  }\n\n  if (delta === 0) {\n    return [-b / (2 * a)];\n  }\n\n  delta = Math.sqrt(delta);\n\n  var root1 = void 0;\n  var root2 = void 0;\n  if (b >= 0) {\n    root1 = (-b - delta) / (2 * a);\n    root2 = 2 * c / (-b - delta);\n  } else {\n    root1 = 2 * c / (-b + delta);\n    root2 = (-b + delta) / (2 * a);\n  }\n\n  if (root1 < root2) {\n    return [root1, root2];\n  }\n  return [root2, root1];\n}\n\n/**\r\n * Calculates the roots of the given cubic polynomial.\r\n * \r\n * This code is mostly from the Pomax guide found at\r\n * https://pomax.github.io/bezierinfo/#extremities\r\n * \r\n * @param {number[]} p - A cubic polynomial.\r\n * @returns {number[]} 1,2 or 3 roots.\r\n */\n// TODO - This function as it currently stands is very sensitive to\n// the first coefficient if it is very small, e.g. compare:\n// cubicRoots([1e-5, 1560,-1740,96]) = [1.1903631761670113, -156000001.1153846, -0.07497859001159668] \n// vs\n// quadraticRoots([1560,-1740,96]) = [0.05821032751613551, 1.0571742878684798]\n// It is completely useless in some ranges of its input domain:\n// the part of the function 'if (discriminant < 0) {}'\n// is highly problematic for numerical stability.\n// Simply use allRoots / allRootsRecursive instead.\n/*\r\nfunction cubicRoots(p) {\r\n\r\n\tfunction cuberoot(v) {\r\n\t\treturn v < 0 \r\n\t\t\t? -Math.pow(-v, 1/3)\r\n\t\t    : +Math.pow(v, 1/3);\r\n\t}\r\n\t\r\n\tlet cbrt = Math.cbrt || cuberoot;\r\n\t\r\n\tlet d = p[0];\r\n\tlet a = p[1] / d;\r\n\tlet b = p[2] / d;\r\n\tlet c = p[3] / d;\r\n\t\r\n\tlet s  = (3*b - a*a) / 9;\r\n\tlet q  = (2*a*a*a - 9*a*b + 27*c) / 54;\r\n\t\r\n\tlet s3 = s*s*s;\r\n\tlet q2 = q*q;\r\n\t\r\n\tlet discriminant = q2 + s3;\r\n\r\n\tif (!Number.isFinite(discriminant)) {\r\n\t\t\r\n\t\t// Overflow occured - in which case one root will be very large. \r\n\t\t// We might want to report such large roots as positive or\r\n\t\t// negative infinity but since they are rarely of interest we\r\n\t\t// report only the smaller roots.\r\n\t\t\r\n\t\t// Here q*q   === (729*c^2 - 486*a*b*c + 108*a^3*c + 81*a^2*b^2 - 36*a^4*b + 4*a^6) / (729*4)\r\n\t\t// and  s*s*s === (27*b^3 - 27*a^2*b^2 + 9*a^4*b - a^6) / (729*1)\r\n\t\t\r\n\t\treturn quadraticRoots(p.slice(1)); \r\n\t}\r\n\t\r\n\tif (discriminant < 0) {\r\n\t\t// three real roots\r\n\t\t\r\n\t\tlet r = Math.sqrt(-s3);\r\n\t\tlet t = -q / r;\r\n\t\t\r\n\t\tlet cosphi = t < -1 ? -1 : t > 1 ? 1 : t;\r\n\t\tlet phi    = Math.acos(cosphi);\r\n\t\tlet\tt1     = 2*cbrt(r);\r\n\t\t\r\n\t\tlet ao3 = a/3; \r\n\t\t\r\n\t\treturn [\r\n\t\t\tt1*Math.cos((phi            )/3) - ao3, \r\n\t\t\tt1*Math.cos((phi + 2*Math.PI)/3) - ao3, \r\n\t\t\tt1*Math.cos((phi + 4*Math.PI)/3) - ao3\r\n\t\t]\r\n\t} else if (discriminant === 0) {\r\n\t\t// three real roots, but two of them are equal\r\n\t\t\r\n\t\tlet u1 = q < 0 ? cbrt(-q) : -cbrt(q);\r\n\t\tlet ao3 = a/3;\r\n\t\t\r\n\t\treturn [\r\n\t\t\t2*u1 - ao3, \r\n\t\t\t-u1 - ao3\r\n\t\t];\r\n\t} else {\r\n\t\t// one real root, two complex roots\r\n\t\t\r\n\t\tlet sd = Math.sqrt(discriminant);\r\n\t\tlet u1 = cbrt(sd - q);\r\n\t\tlet v1 = cbrt(sd + q);\r\n\t\t\r\n\t\treturn [u1 - v1 - a/3];\r\n\t}\r\n}\r\n*/\n\n/** \r\n * Returns the number of real roots in the interval (a,b) of the given \r\n * polynomial.\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @param {number} a - The lower bound\r\n * @param {number} b - The upper bound\r\n * @returns {number} The number of roots in the given interval\r\n * @example \r\n * let p = [1, 1, -64, 236, -240];\r\n * FloPoly.numRootsWithin(p,-20,-11); //=> 0\r\n * FloPoly.numRootsWithin(p,-11,-9);  //=> 1  \r\n * FloPoly.numRootsWithin(p,-11,3.5); //=> 3\r\n * FloPoly.numRootsWithin(p,-11,5);   //=> 4\r\n */\nfunction numRootsWithin(p, a, b) {\n  var ps = sturmChain(p);\n  var ev = evaluate(p);\n  var as = ps.map(function (p) {\n    return evaluate(p)(a);\n  });\n  var bs = ps.map(function (p) {\n    return evaluate(p)(b);\n  });\n\n  return signChanges(as) - signChanges(bs);\n}\n\n/**\r\n * <p>\r\n * Searches an interval (a,b) for a root (i.e. zero) of the \r\n * given function with respect to its first argument using the Bisection \r\n * Method root-finding algorithm. Any function can be supplied (it does\r\n * not even have to be continuous) as long as the root is bracketed. \r\n * </p>\r\n * <p>\r\n * Note: This function has no advantages above the Brent method except\r\n * for its simpler implementation and can be much slower. Use brent \r\n * instead.\r\n * </p>\r\n * @param {function} f - The function for which the root is sought.\r\n * @param {number} a - The lower limit of the search interval.\r\n * @param {number} b - The upper limit of the search interval.\r\n * @returns {number} An estimate of the root to within δ (typically \r\n * about 1e-15 multiplied by the root magnitued).\r\n * @example\r\n * let p = FloPoly.fromRoots([-10,2,3,4]);  //=> [1, 1, -64, 236, -240]\r\n * let f = FloPoly.evaluate(p);\r\n * FloPoly.bisection(f,2.2,3.8); //=> 3\r\n * FloPoly.bisection(f,2.2,3.1); //=> 3.0000000000000044\r\n */\nfunction bisection(f, a, b) {\n  if (a === b) {\n    // Presumably the root is already found.\n    return a;\n  } else if (b < a) {\n    // Swap a and b \n    var _ref = [b, a];\n    a = _ref[0];\n    b = _ref[1];\n  }\n\n  var fa = f(a);\n  var fb = f(b);\n\n  if (fa === 0) {\n    return a;\n  }\n  if (fb === 0) {\n    return b;\n  }\n\n  if (fa * fb > 0) {\n    // Root is not bracketed - this is a precondition.\n    throw new Error('Root not bracketed');\n  }\n\n  while (true) {\n    var c = a + (b - a) / 2; // Take midpoint\n    var fc = f(c);\n\n    if (fc === 0) {\n      return c;\n    }\n\n    if (fa * fc < 0) {\n      b = c;\n    } else {\n      a = c;\n    }\n\n    // We don't add Number.EPSILON in the line below because we want\n    // accuracy to improve even below 1.\n    var δ = 2 * Number.EPSILON * Math.abs(b) /*+ Number.EPSILON*/;\n    if (Math.abs(a - b) <= δ) {\n      return b;\n    }\n  }\n}\n\n/**\r\n * <p>\r\n * Searches an interval (a,b) for a root (i.e. zero) of the \r\n * given function with respect to its first argument using the Brent's \r\n * Method root-finding algorithm. Any function can be supplied (it does\r\n * not even have to be continuous) as long as the root is bracketed. \r\n * </p>\r\n * <p>\r\n * Brent's Method is an excellent root-finding choice since it is\r\n * (1) guaranteed to converge (unlike the Newton and other so-called \r\n * single-point methods), (2) converges in a reasonable number of \r\n * iterations even for highly contrived functions (unlike Dekker's \r\n * Method) and (3) nearly always converges extremely fast, i.e. super-\r\n * linearly (unlike the Secant and Regula-Falsi methods).\r\n * </p>\r\n * <p>\r\n * The max error, δ, is set equal to 2*Number.EPSILON*Math.abs(b) \r\n * + Number.EPSILON after each iteration where b is the current best \r\n * guess. A much larger δ of say 1e-10 does not really make sense\r\n * for polynomials since nearly always by that stage convergence \r\n * proceeds superlinearly and by the next iteration a δ of\r\n * around Number.EPSILON is achieved. On the other hand, a δ of \r\n * much less than Number.EPSILON is sometimes useful, say for finding  \r\n * the root of the polynomial x**2 - 3*x*1e-13 + 2*1e-26 to within less\r\n * than 1e-15, but this is rare enough not to be considered in this \r\n * implementation. (For JavaScript doubles Number.EPSILON === \r\n * 2.220446049250313e-16 and since b is typically around 1 the max δ \r\n * will be about 3*2.220446049250313e-16 or about 1e-15. As another \r\n * example, a root near -1000 will have a max error, i.e. δ, of \r\n * about 1e-12. In conclusion, for roots near zero the error can be up\r\n * to Number.EPSILON or about 1e-15 - we don't bother to calculate the\r\n * root more accurately than this since it may require up to 4 or 5 \r\n * additional iterations.\r\n * </p>\r\n * <p> \r\n * See <a href=\"https://en.wikipedia.org/wiki/Brent%27s_method\">Wikipedia</a>\r\n * </p>\r\n * <p>\r\n * See <a href=\"https://maths-people.anu.edu.au/~brent/pd/rpb011i.pdf\">Brent (page 47)</a>\r\n * </p>\r\n * @param {function} f - The function for which the root is sought.\r\n * @param {number} a - The lower limit of the search interval.\r\n * @param {number} b - The upper limit of the search interval.\r\n * @returns {number} An estimate of the root to within δ (typically \r\n * about 1e-15 multiplied by the root magnitued).\r\n * @example\r\n * let p = FloPoly.fromRoots([-10,2,3,4]);  //=> [1, 1, -64, 236, -240]\r\n * let f = FloPoly.evaluate(p);\r\n * FloPoly.brent(f,2.2,3.8); //=> 3.000000000000003\r\n * FloPoly.brent(f,2.2,3.1); //=> 3.000000000000001\r\n */\nfunction brent(f, a, b) {\n  if (a === b) {\n    // Presumably the root is already found.\n    return a;\n  }\n\n  // We assume on the first iteration f(a) !== 0 && f(b) !== 0. \n  var fa = f(a);\n  var fb = f(b);\n\n  if (fa * fb > 0) {\n    // Root is not bracketed - this is a precondition.\n    throw new Error('Root not bracketed');\n  }\n\n  var c = void 0; // Value of previous guess - set to a initially \n  if (Math.abs(fa) < Math.abs(fb)) {\n    // Swap a,b\n    c = a;a = b;b = c;\n\n    // Swap fa,fb\n    var temp = fa;\n    fa = fb;\n    fb = temp;\n  }\n\n  c = a;\n\n  var mflag = true;\n  var d = void 0; // Value of guess before previous guess\n  while (true) {\n    var δ = 2 * Number.EPSILON * Math.abs(b) + Number.EPSILON;\n\n    var fc = f(c);\n\n    // Calculate provisional interpolation value\n    var s = void 0;\n    if (fa !== fc && fb !== fc) {\n      // 3 points available - inverse quadratic interpolation\n      var fac = fa - fc;\n      var fab = fa - fb;\n      var fbc = fb - fc;\n\n      // The below has been multiplied out to speed up the algorithm.\n      /*s = ((a * fb * fc) / ( fab * fac)) +\r\n      \t  ((b * fa * fc) / (-fab * fbc)) +\r\n      \t  ((c * fa * fb) / ( fac * fbc));*/\n      s = ((a * fb * fbc - b * fa * fac) * fc + c * fa * fab * fb) / (fab * fac * fbc);\n    } else {\n      // only 2 points available - secant method\n      s = b - fb * ((b - a) / (fb - fa));\n    }\n\n    var t1 = (3 * a + b) / 4;\n    var b_c = Math.abs(b - c);\n    var s_b = Math.abs(s - b);\n    var c_d = Math.abs(c - d);\n\n    if (!( // condition 1\n    s > t1 && s < b || s < t1 && s > b) || mflag && (\n    // condition 2\n    s_b >= b_c / 2 ||\n    // condition 4\n    b_c < δ) || !mflag && (\n    // condition 3\n    s_b >= c_d / 2 ||\n    // condition 5\n    c_d < δ)) {\n      // Bisection\n      s = (a + b) / 2;\n      mflag = true;\n    } else {\n      mflag = false;\n    }\n\n    var fs = f(s);\n\n    d = c;\n    c = b;\n\n    if (fa * fs < 0) {\n      b = s;\n    } else {\n      a = s;\n    }\n\n    if (Math.abs(fa) < Math.abs(fb)) {\n      // Swap a,b\n      var _temp = a;a = b;b = _temp;\n    }\n\n    if (fb === 0) {\n      return b;\n    }\n    if (fs === 0) {\n      return s;\n    }\n\n    if (Math.abs(a - b) <= δ) {\n      return b;\n    }\n\n    fa = f(a);\n    fb = f(b);\n  }\n}\n\nmodule.exports = rootOperators;\n\n},{\"./core-operators.js\":2}]},{},[4])(4)\n});"]}