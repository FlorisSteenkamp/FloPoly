{"version":3,"sources":["flo-poly.min.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","FloPoly","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","allRootsRecursive","p","b","clip0","undefined","INF","d","rangeFilter","inRange","quadraticRoots","filter","lowerBound","upperBound","negativeRootLowerBound_LMQ","positiveRootUpperBound_LMQ","dp","differentiate","roots","unshift","push","rootsWithin","x","intervals","peval","evaluate","prevRoot","root","evA","evB","brent","coreOperators","rootOperators","rootBounds","toCasStr","rootMagnitudeUpperBound_fujiwara","positiveRootLowerBound_LMQ","negativeRootUpperBound_LMQ","Number","POSITIVE_INFINITY","./core-operators.js","./root-bounds.js","./root-operators.js","2","allRootsVAS","p_","removeZeroRoots","numZeros","vasRoots","vasRootIntervals","map","interval","slice","evaluateAt0","pop","concat","vasRootIntervalsHelper","mobius","signVariations","signChanges","M0","Mobius","MI","evaluateAtInf","MM0","Math","min","MMI","max","lb","changeVariables","p01","invert","M01","m","p1inf","M1inf","intervals1","intervals3","negate","./mobius.js","3","add","p1","p2","d1","d2","Δd","Δd1","Δd2","result","c1","c2","subtract","multiplyByConst","multiply","Array","fill","j","c","degree","prevSign","sign","deflate","bs","reverse","_i","res","_i2","_j","acc","reflectAboutYAxis","sturmChain","pnext","shift","clip","δ_","δ","EPSILON","maxCoefficient","abs","str","cStr","toString","4","conditionNumber","pow","hornerErrorBound","errorAnalysis","5","fromRoots","random","Object","assign","allRoots","./all-roots-recursive.js","./all-roots-vas.js","./error-analysis.js","./random.js","6","changeVariables1","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_s","Symbol","iterator","next","done","value","err","isArray","TypeError","_mobius","_mobius$","_mobius$2","_mobius2","_mobius2$","_mobius2$2","7","predictiveRandom","seed","RANGE","randomArray","odds","SEED","vs","values","flatRoots","randArr","flatCoefficients","createArrFunction","v","flatRootsArr","flatCoefficientsArr","8","an","apply","deg","timesUsed","ub","tempub","any","k","temp","9","_p","delta","sqrt","root1","root2","numRootsWithin","ps","as","EPS","fa","fb","mflag","fc","fac","fab","fbc","t1","b_c","s_b","c_d","fs","_temp"],"mappings":"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","file":"flo-poly.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.FloPoly = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nvar coreOperators = require('./core-operators.js');\nvar rootOperators = require('./root-operators.js');\nvar rootBounds = require('./root-bounds.js');\n\nvar brent = rootOperators.brent,\n    quadraticRoots = rootOperators.quadraticRoots;\nvar clip0 = coreOperators.clip0,\n    evaluate = coreOperators.evaluate,\n    differentiate = coreOperators.differentiate,\n    toCasStr = coreOperators.toCasStr;\nvar rootMagnitudeUpperBound_fujiwara = rootBounds.rootMagnitudeUpperBound_fujiwara,\n    positiveRootUpperBound_LMQ = rootBounds.positiveRootUpperBound_LMQ,\n    positiveRootLowerBound_LMQ = rootBounds.positiveRootLowerBound_LMQ,\n    negativeRootUpperBound_LMQ = rootBounds.negativeRootUpperBound_LMQ,\n    negativeRootLowerBound_LMQ = rootBounds.negativeRootLowerBound_LMQ;\n\n\nvar INF = Number.POSITIVE_INFINITY;\n\n/**\r\n * <p>Finds a near optimal approximation to the real roots (or those \r\n * within a range) of the input polynomial.\r\n * </p>\r\n * <p>\r\n * Only multiple roots of even order that is very close together may be \r\n * missed. (This is rarely a problem in practice - in a geometrical \r\n * application, for instance, this may mean two objects are barely \r\n * touching and returning either, all, or none of the repeated even \r\n * roots should not break the algorithm). \r\n * </p>\r\n * \r\n * @alias allRoots\r\n * @param {number[]} p - The polynomial\r\n * @param {number} a - Lower limit of root values that should be \r\n * returned - defaults to -∞\r\n * @param {number} b - Upper limit of root values that should be \r\n * returned - defaults to +∞\r\n * @returns {number[]} The found roots.\r\n * @impl_notes\r\n * @example\r\n * FloPoly.allRoots([1, -10, 35, -50, 24]); //=> [1, 2.0000000000000036, 3.0000000000000067, 4] \r\n */\nfunction allRootsRecursive(p, a, b) {\n\tp = clip0(p);\n\ta = a === undefined ? -INF : a;\n\tb = b === undefined ? +INF : b;\n\n\tvar d = p.length - 1;\n\tvar rangeFilter = inRange(a, b);\n\n\tif (d === 2) {\n\t\treturn quadraticRoots(p).filter(rangeFilter);\n\t\t// Investigate if any numerically stable algorithm could be as fast\n\t\t// as this algorithm (i.e by finding cubic roots within quadratic\n\t\t// root demarcated intervals via Brent's method. The cubicRoots \n\t\t// algoritm below has been removed since it was numerically \n\t\t// unstable.\n\t\t/*} else if (d === 3) {\r\n  \treturn cubicRoots(p)\r\n  \t\t.filter(rangeFilter)\r\n  \t\t.sort((a,b) => a-b)\r\n  } else if (d > 3) {*/\n\t} else if (d > 2) {\n\t\t// TODO The root bounding function below might have an impact on \n\t\t// performance - it would probably be better to use \n\t\t// positiveRootUpperBound_LMQ or (possibly) even better, the \n\t\t// linear version of it (see paper of Viglas, Akritas and \n\t\t// Strzebonski) and re-calculate bounds on every iteration.\n\t\tvar lowerBound = void 0;\n\t\tvar upperBound = void 0;\n\t\tif (a === -INF || b === +INF) {\n\t\t\t//let magnitudeBound = rootMagnitudeUpperBound_fujiwara(p);\n\t\t\t//lowerBound = a === -INF ? -magnitudeBound : a;\n\t\t\t//upperBound = b === +INF ? +magnitudeBound : b;\n\n\t\t\tlowerBound = a === -INF ? negativeRootLowerBound_LMQ(p) : a;\n\t\t\tupperBound = b === +INF ? positiveRootUpperBound_LMQ(p) : b;\n\t\t} else {\n\t\t\tlowerBound = a;\n\t\t\tupperBound = b;\n\t\t}\n\n\t\t// If the roots of differentiated polynomial is out of range \n\t\t// then the roots of the polynomial itself will also be out of \n\t\t// range.\n\t\tvar dp = differentiate(p);\n\t\tvar roots = allRootsRecursive(dp, lowerBound, upperBound).filter(rangeFilter);\n\n\t\tif (roots[0] !== lowerBound) {\n\t\t\troots.unshift(lowerBound); // Not really a root.\n\t\t}\n\t\tif (roots[roots.length - 1] !== upperBound) {\n\t\t\troots.push(upperBound); // Not really a root.\n\t\t}\n\t\treturn rootsWithin(p, roots);\n\t} else if (d === 1) {\n\t\t// Less likely so put near bottom (micro optimization)\n\t\treturn [-p[1] / p[0]].filter(rangeFilter);\n\t} else if (d === 0) {\n\t\treturn []; // y = c -> no roots\t\n\t}\n\n\t// Least likely so put at bottom (micro optimization)\n\t// d === -1\n\t// y = 0 -> infinite number of roots\n\treturn [];\n}\n\n/**\r\n * Returns a function that returns true if x is in the range [a,b].\r\n *  \r\n * @ignore\r\n * @param {number} a\r\n * @param {number} b\r\n * @returns {function}\r\n */\nfunction inRange(a, b) {\n\treturn function (x) {\n\t\treturn x >= a && x <= b;\n\t};\n}\n\n/**\r\n * Finds all roots of the given polynomial within the given intervals.\r\n *  \r\n * @ignore\r\n * @param {number[]} p\r\n * @param {number[]} intervals\r\n * @returns {number[]} The found roots.\r\n */\nfunction rootsWithin(p, intervals) {\n\n\tvar roots = [];\n\tvar peval = evaluate(p);\n\n\tvar prevRoot = void 0;\n\tvar a = intervals[0];\n\tfor (var i = 1; i < intervals.length; i++) {\n\t\tvar root = void 0;\n\t\tvar b = intervals[i];\n\n\t\tvar evA = peval(a);\n\t\tvar evB = peval(b);\n\n\t\tvar k = evA * evB;\n\n\t\tif (k === 0) {\n\t\t\tif (evA === 0) {\n\t\t\t\troot = a;\n\t\t\t} else if (evB === 0 && i === intervals.length - 1) {\n\t\t\t\troot = b;\n\t\t\t}\n\t\t} else if (evA * evB < 0) {\n\t\t\troot = brent(peval, a, b);\n\t\t}\n\n\t\t// Add root if it exists and suppress exact duplicates\n\t\tif (root !== undefined && root !== prevRoot) {\n\t\t\troots.push(root);\n\t\t\tprevRoot = root;\n\t\t}\n\n\t\ta = b;\n\t}\n\n\treturn roots;\n}\n\nmodule.exports = allRootsRecursive;\n\n},{\"./core-operators.js\":3,\"./root-bounds.js\":8,\"./root-operators.js\":9}],2:[function(require,module,exports){\n'use strict';\n\nvar coreOperators = require('./core-operators.js');\nvar rootOperators = require('./root-operators.js');\nvar Mobius = require('./mobius.js');\nvar rootBounds = require('./root-bounds.js');\n\nvar brent = rootOperators.brent;\nvar evaluate = coreOperators.evaluate,\n    evaluateAt0 = coreOperators.evaluateAt0,\n    negate = coreOperators.negate,\n    invert = coreOperators.invert,\n    signChanges = coreOperators.signChanges,\n    changeVariables = coreOperators.changeVariables;\nvar positiveRootUpperBound_LMQ = rootBounds.positiveRootUpperBound_LMQ,\n    positiveRootLowerBound_LMQ = rootBounds.positiveRootLowerBound_LMQ;\n\n/** \r\n * DO NOT USE. EXPERIMENTAL.\r\n * Find all the roots using the VAS algorithm followed by Brent's \r\n * method.\r\n *  \r\n * @ignore\r\n * @param {number[]} p - A square-free polynomial.\r\n * @returns {number[]} The roots.\r\n **/\n\nfunction allRootsVAS(p_) {\n\t// TODO - First remove all zero roots  - The VAS method can't handle \n\t// them.\n\tvar p = removeZeroRoots(p_);\n\tvar numZeros = p_.length - p.length;\n\n\t// TODO - Next, remove all multiple roots (i.e. do a square-free\n\t// factorization... - VAS doesn't like them either\n\n\tvar vasRoots = vasRootIntervals(p).map(function (interval) {\n\t\treturn brent(evaluate(p), interval[0], interval[1]);\n\t});\n\n\tfor (var i = 0; i < numZeros; i++) {\n\t\tvasRoots.push(0);\n\t}\n\n\treturn vasRoots;\n}\n\n/**\r\n * Removes the zero roots from the polynomial.\r\n * \r\n * @ignore\r\n * @returns {number[]} The deflated polynomial.\r\n *       \r\n */\n// TODO - improve this function: readability + floating point tolerance\nfunction removeZeroRoots(p_) {\n\tvar p = p_.slice();\n\tvar i = 0;\n\twhile (evaluateAt0(p) === 0) {\n\t\tvar len = p.length;\n\t\tp.pop();\n\t\ti++;\n\t}\n\n\treturn p;\n}\n\n/** \r\n * Finds root intervals of a polynomial such that each interval contains\r\n * exactly one root using the VAS (Vincent–Akritas–Strzeboński) method.\r\n * \r\n * @ignore\r\n * @see http://www.e-ce.uth.gr/wp-content/uploads/formidable/phd_thesis_vigklas.pdf\r\n */\n// TODO - Square-free factorization ignored for now - duplicate roots \n// could cause an infinite loop - fix by checking if interval becomes\n// smaller than a certain threshold.\nfunction vasRootIntervals(p) {\n\n\tvar positiveIntervals = vasRootIntervalsHelper(p, [[1, 0], [0, 1]]);\n\n\t// ONLY COMMENTED BECAUSE IN *OUR* CASE WE DONT CARE ABOUT NEGATIVE ROOTS!!\n\t/*\r\n let negativeIntervals = vasRootIntervalsHelper(\r\n \tchangeVariables(p.slice(), -1, 0), \r\n \t[[1,0],[0,1]]\r\n )\r\n .map(function(interval) {\r\n \treturn negate(invert(interval));\r\n });\r\n */\n\n\tvar intervals = [].concat(\n\t//negativeIntervals, \n\tpositiveIntervals);\n\n\treturn intervals;\n}\n\n/** \r\n * Helper function\r\n * The initial mobius transformation must be [[1,0],[0,1]] = M(x) = x.\r\n * \r\n * @ignore\r\n */\nfunction vasRootIntervalsHelper(p, mobius) {\n\n\t// In the Vigklas, Akritas, Strzebonski paper, the steps are marked \n\t// as below:\n\n\t// STEP 1\n\tvar intervals = [];\n\tvar signVariations = signChanges(p);\n\n\t// STEP 2\n\tif (signVariations === 0) {\n\t\t// Descartes' rule of signs\n\t\treturn [];\n\t}\n\n\t// STEP 3\n\tif (signVariations === 1) {\n\t\tvar M0 = Mobius.evaluateAt0(mobius);\n\t\tvar MI = Mobius.evaluateAtInf(mobius);\n\t\tvar MM0 = Math.min(M0, MI);\n\t\tvar MMI = Math.max(M0, MI);\n\t\tif (MMI === Number.POSITIVE_INFINITY) {\n\t\t\tMMI = Mobius.evaluate(mobius, positiveRootUpperBound_LMQ(p));\n\t\t}\n\n\t\treturn [[MM0, MMI]];\n\t}\n\n\t// STEP 4\n\tvar lb = positiveRootLowerBound_LMQ(p);\n\n\t// STEP 5\n\tif (lb > 1) {\n\t\t// p ← p(x + lb)\n\t\tp = changeVariables(p, 1, lb);\n\n\t\t// M ← M(x + lb)\n\t\tmobius = Mobius.changeVariables(mobius, 1, lb);\n\t}\n\n\t// TODO - Include factor of 16 improvement by Strzebonski\n\n\t// STEP 6 - Look for real roots in (0, 1)\n\n\t// p01 ← (x + 1)^(deg(p)) *  p(1/(x+1))\n\tvar p01 = changeVariables(invert(p), 1, 1);\n\n\t// M01 ← M(1/(x+1))\n\tvar M01 = Mobius.changeVariables(Mobius.invert(mobius), 1, 1);\n\n\t// STEP 7 - Is 1 a root?\n\tvar m = Mobius.evaluate(mobius, 1);\n\n\t// STEP 8 - Look for real roots in (1, ∞)\n\n\t// p1∞ ← p(x + 1)\n\tvar p1inf = changeVariables(p, 1, 1);\n\n\t// M1∞ ← M(x + 1)\n\tvar M1inf = Mobius.changeVariables(mobius, 1, 1);\n\n\t// STEPS 9 -> 13\n\tvar intervals1 = vasRootIntervalsHelper(p01, M01);\n\tvar intervals3 = vasRootIntervalsHelper(p1inf, M1inf);\n\n\tif (evaluate(p)(1) === 0) {\n\t\tintervals1.push([m, m]);\n\t}\n\n\treturn [].concat(intervals1, intervals3);\n}\n\nmodule.exports = allRootsVAS;\n\n},{\"./core-operators.js\":3,\"./mobius.js\":6,\"./root-bounds.js\":8,\"./root-operators.js\":9}],3:[function(require,module,exports){\n'use strict';\n\nvar coreOperators = {\n\tadd: add,\n\tsubtract: subtract,\n\tmultiplyByConst: multiplyByConst,\n\tnegate: negate,\n\tdifferentiate: differentiate,\n\tmultiply: multiply,\n\tdegree: degree,\n\tevaluate: evaluate,\n\tevaluateAt0: evaluateAt0,\n\tsignChanges: signChanges,\n\tinvert: invert,\n\tchangeVariables: changeVariables,\n\treflectAboutYAxis: reflectAboutYAxis,\n\tsturmChain: sturmChain,\n\tclip: clip,\n\tclip0: clip0,\n\tdeflate: deflate,\n\tmaxCoefficient: maxCoefficient,\n\ttoCasStr: toCasStr\n};\n\n/**\r\n * Adds two polynomials.\r\n * \r\n * @param {number[]} p1 - The first polynomial\r\n * @param {number[]} p2 - The second polynomial\r\n * @returns {number[]} p1 + p2.\r\n * @example\r\n * FloPoly.add([1,2,3],[3,4]); //=> [1,5,7]\r\n */\nfunction add(p1, p2) {\n\t// Initialize result array  \n\tvar d1 = p1.length - 1;\n\tvar d2 = p2.length - 1;\n\tvar Δd = d1 - d2;\n\n\tvar Δd1 = 0;\n\tvar Δd2 = 0;\n\tif (Δd > 0) {\n\t\tΔd2 = -Δd;\n\t} else if (Δd < 0) {\n\t\tΔd1 = +Δd;\n\t}\n\n\tvar d = Math.max(d1, d2);\n\n\t// Add coefficients\n\tvar result = [];\n\tfor (var i = 0; i < d + 1; i++) {\n\t\tvar c1 = p1[i + Δd1];\n\t\tvar c2 = p2[i + Δd2];\n\t\tresult.push((c1 || 0) + (c2 || 0));\n\t}\n\n\treturn clip0(result);\n}\n\n/** \r\n * Subtracts the second polynomial from first.\r\n * \r\n * @param {number[]} p1 - The polynomial from which will be subtracted\r\n * @param {number[]} p2 - The polynomial that will be subtracted\r\n * @returns {number[]} p1 - p2\r\n * @example\r\n * FloPoly.subtract([2,3],[4,4]); //=> [-2, -1]\r\n */\nfunction subtract(p1, p2) {\n\t// Initialize result array  \n\tvar d1 = p1.length - 1;\n\tvar d2 = p2.length - 1;\n\tvar Δd = d1 - d2;\n\n\tvar Δd1 = 0;\n\tvar Δd2 = 0;\n\tif (Δd > 0) {\n\t\tΔd2 = -Δd;\n\t} else if (Δd < 0) {\n\t\tΔd1 = +Δd;\n\t}\n\n\tvar d = Math.max(d1, d2);\n\n\t// Add coefficients\n\tvar result = [];\n\tfor (var i = 0; i < d + 1; i++) {\n\t\tvar c1 = p1[i + Δd1];\n\t\tvar c2 = p2[i + Δd2];\n\t\tresult.push((c1 || 0) - (c2 || 0));\n\t}\n\n\treturn clip0(result);\n}\n\n/**\r\n * Negate the given polynomial (p -> -p).  \r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number[]} -p\r\n * @example\r\n * FloPoly.negate([0.1, -0.2]); //=> [-0.1, 0.2]\r\n */\nfunction negate(p) {\n\treturn multiplyByConst(-1, p);\n}\n\n/**  \r\n * Differentiates the given polynomial.\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number[]} D(p)\r\n * @example\r\n * FloPoly.differentiate([5, 4, 3, 2, 1]); //=> [20, 12, 6, 2]\r\n */\nfunction differentiate(p) {\n\n\tvar result = [];\n\n\tvar d = p.length - 1;\n\tfor (var i = 0; i < d; i++) {\n\t\tresult.push((d - i) * p[i]);\n\t}\n\n\treturn result;\n}\n\n/** \r\n * Multiplies the two given polynomials and returns the result. \r\n * \r\n * @param {number[]} p1 - The one polynomial.\r\n * @param {number[]} p2 - The other polynomial.\r\n * @returns {number[]} p1 * p2\r\n * \r\n * @see https://en.wikipedia.org/wiki/Polynomial_arithmetic \r\n * @see https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Polynomial_multiplication\r\n * @see http://web.cs.iastate.edu/~cs577/handouts/polymultiply.pdf\r\n * \r\n * @example\r\n * FloPoly.multiply([1,2,3], [2,5,3,5]); //=> [2, 9, 19, 26, 19, 15]\r\n */\n// TODO Currently using O(n^2) algorithm - possibly change to a faster  \n// FFT algorithm for high degree polynomials? No, we are interested in\n// polynomials of degree 20 or lower.\nfunction multiply(p1, p2) {\n\tvar d1 = p1.length - 1;\n\tvar d2 = p2.length - 1;\n\tvar d = d1 + d2;\n\n\tvar result = new Array(d + 1).fill(0);\n\tfor (var i = 0; i < d1 + 1; i++) {\n\t\tfor (var j = 0; j < d2 + 1; j++) {\n\t\t\tresult[d - (i + j)] += p1[d1 - i] * p2[d2 - j];\n\t\t}\n\t}\n\n\treturn clip0(result);\n}\n\n/** \r\n * Multiplies 2 polynomials by a constant.\r\n * \r\n * @param {number} c - The constant\r\n * @param {number[]} p - The polynomial\r\n * @returns {number[]} c*p\r\n * @example \r\n * FloPoly.multiplyByConst(0.25, [3,2,1]); //=> [0.75, 0.5, 0.25]  \r\n */\nfunction multiplyByConst(c, p) {\n\tif (c === 0) {\n\t\treturn [];\n\t}\n\n\tvar d = p.length - 1;\n\tvar result = [];\n\tfor (var i = 0; i < d + 1; i++) {\n\t\tresult.push(c * p[i]);\n\t}\n\n\treturn result;\n}\n\n/** \r\n * Returns the degree of the polynomial.\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number} \r\n * @example \r\n * FloPoly.degree([9,8,7,6,5,4,3,2,1]); //=> 9\r\n */\nfunction degree(p) {\n\treturn p.length - 1;\n}\n\n/** \r\n * Evaluates a univariate polynomial using Horner's method. This \r\n * function is curried (see examples below).  \r\n * \r\n * @see https://en.wikipedia.org/wiki/Horner%27s_method\r\n * @param {number[]} p - The polynomial\r\n * @param {number} a - The value at which to evaluate the polynomial.\r\n * @returns {number|function} The result if both parameters are supplied\r\n * or a function with arity one if only the first parameter is supplied.\r\n * @example\r\n * let ev = FloPoly.evaluate([3,2,1]);\r\n * ev(1); // => 6\r\n * ev(2); // => 17\r\n * \t\t \r\n * FloPoly.evaluate([3,2,1], 1); // => 6\r\n * FloPoly.evaluate([3,2,1], 2); // => 17\r\n * \r\n * FloPoly.evaluate([3,2,1])(1); // => 6\r\n * FloPoly.evaluate([3,2,1])(2); // => 17\r\n */\nfunction evaluate(p, a) {\n\tfunction evaluate(a) {\n\t\t//if p.length === 0 { return 0; }\n\t\tvar result = p[0];\n\t\tfor (var i = 1; i < p.length; i++) {\n\t\t\tresult = p[i] + result * a;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// Curry the function\n\treturn a === undefined ? evaluate : evaluate(a);\n}\n\n/** \r\n * Evaluates the given polynomial at 0 - it is much faster than at an \r\n * arbitrary point. \r\n *  \r\n * @param {number[]} p - The polynomial\r\n * @returns {number}\r\n * @example\r\n * FloPoly.evaluateAt0([3,2,99]); //=> 99\r\n */\nfunction evaluateAt0(p) {\n\treturn p[p.length - 1];\n};\n\n/** \r\n * <p>\r\n * Returns the number of sign changes in the polynomial coefficents \r\n * when ordered in descending order; zeros are ignored.\r\n * </p>\r\n * <p>\r\n * Descartes' rule of signs states (quoted from Wikipedia):\r\n * \"if the terms of a polynomial are ordered by descending variable \r\n * exponent, then the number of positive roots of the polynomial is \r\n * either equal to the number of sign differences between consecutive \r\n * nonzero coefficients, or is less than it by an even number. Multiple \r\n * roots of the same value are counted separately.\"\r\n * </p>\r\n * @see https://en.wikipedia.org/wiki/Descartes%27_rule_of_signs\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number} The number of sign changes.\r\n * @example\r\n * FloPoly.signChanges([1,2,-3,0,0,3,-1]); //=> 3\r\n */\nfunction signChanges(p) {\n\tvar d = p.length - 1;\n\n\tvar result = 0;\n\tvar prevSign = Math.sign(p[0]);\n\tfor (var i = 1; i < d + 1; i++) {\n\t\tvar sign = Math.sign(p[i]);\n\n\t\tif (sign !== prevSign && sign !== 0) {\n\t\t\tresult++;\n\t\t\tprevSign = sign;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\r\n * Deflates the given polynomial by removing a factor (x - r), where\r\n * r is a root of the polynomial.\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @param {number} root - A pre-calculated root of the polynomial.\r\n * @returns {number[]} The deflated polynomial.\r\n * @example\r\n * // The polynomial x^3 - 5x^2 + 8x - 4 has a root at 1 and a double root at 2 \r\n * FloPoly.deflate([1, -5, 8, -4], 2); //=> [1, -3, 2] \r\n * FloPoly.deflate([1, -3, 2], 2);     //=> [1,-1] \r\n * FloPoly.deflate([1, -1], 1);        //=> [1]\r\n */\nfunction deflate(p, root) {\n\tvar d = p.length - 1;\n\tvar bs = [p[0]];\n\tfor (var i = 1; i < p.length - 1; i++) {\n\t\tbs.push(p[i] + root * bs[i - 1]);\n\t}\n\n\treturn bs;\n}\n\n/**\r\n * Inverts the given polynomial by reversing the order of the \r\n * coefficients.\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number} p(x) -> x^deg(p) * p(1/x)\r\n * @example\r\n * FloPoly.invert([1,2,3,4]); // => [4,3,2,1]\r\n * FloPoly.invert([3,2,-5]);  // => [-5,2,3]\r\n */\nfunction invert(p) {\n\treturn p.slice().reverse();\n}\n\n/** \r\n * Performs a change of variables of the form: p(x) <- p(ax + b).\r\n * @see http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @param {number} a\r\n * @param {number} b\r\n * @returns {number[]} The transformed polynomial.\r\n * @example\r\n * FloPoly.changeVariables([1,2,7], 3, 4); //=> [9, 30, 31]\r\n */\nfunction changeVariables(p, a, b) {\n\t// We let the coefficients of p(ax + b) be denoted by d_i in the \n\t// code below. \n\t// d_i is calculated as d = T*c, where c are the original \n\t// coefficients.\n\n\tvar d = p.length - 1;\n\n\t// Initialize a zero matrix\n\tvar t = [];\n\tfor (var i = 0; i < d + 1; i++) {\n\t\tt.push(new Array(d + 1).fill(0));\n\t}\n\n\t// Calculate the triangular matrix T\n\tt[0][0] = 1;\n\tfor (var j = 1; j <= d; j++) {\n\t\tt[0][j] = b * t[0][j - 1];\n\t\tfor (var _i = 1; _i <= j; _i++) {\n\t\t\tt[_i][j] = b * t[_i][j - 1] + a * t[_i - 1][j - 1];\n\t\t}\n\t}\n\n\t// Multiply\n\tvar res = new Array(d + 1).fill(0);\n\tfor (var _i2 = 0; _i2 <= d; _i2++) {\n\t\tres[d - _i2] = 0;\n\t\tfor (var _j = _i2; _j <= d; _j++) {\n\t\t\tvar acc = t[_i2][_j] * p[d - _j];\n\t\t\tres[d - _i2] += acc;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n/**\r\n * Reflects the given polynomial about the Y-axis, i.e. perform the \r\n * change of variables: p(x) <- p(-x).\r\n * \r\n * @param {number[]} p - The polynomial to reflect\r\n * @returns {number[]} The reflected polynomial.\r\n * @example\r\n * FloPoly.reflectAboutYAxis([5,4,3,2,1]); //=> [5, -4, 3, -2, 1]\r\n */\nfunction reflectAboutYAxis(p) {\n\tvar d = p.length - 1;\n\n\tvar result = p.slice();\n\tfor (var i = 0; i < d + 1; i++) {\n\t\tif (i % 2) {\n\t\t\tresult[i] = -result[i];\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/** \r\n * Generates a sturm chain for the given polynomial.\r\n * \r\n * @see https://en.wikipedia.org/wiki/Sturm%27s_theorem\r\n * @param {number[]} p - The polynomial\r\n * @returns {number[][]} The sturm chain of polynomials\r\n * @example\r\n * FloPoly.sturmChain([-3,4,2,-2]); //=> [[-3, 4, 2, -2], [-9, 8, 2], [-2.5185185185185186, 1.7037037037037037], [-3.2932525951557086]]\r\n */\nfunction sturmChain(p) {\n\n\t/** \r\n  * Returns the negative of the remainder when dividing the first \r\n  * polynomial (the dividend) by the second (the divisor) provided \r\n  * that deg(p1) - deg(p2) === 1.\r\n  * \r\n  * @ignore\r\n  * @param {number[]} p1 - The first polynomial (dividend)\r\n  * @param {number[]} p2 - The second polynomial (divisor)\r\n  * @see https://en.wikipedia.org/wiki/Sturm%27s_theorem\r\n  */\n\tfunction negRemainder(p1, p2) {\n\t\tvar d1 = p1.length - 1;\n\t\tvar d2 = p2.length - 1;\n\t\tvar d = d1 - d2;\n\n\t\tvar a = p1[1] / p1[0] - p2[1] / p2[0];\n\t\tvar b = p1[0] / p2[0];\n\n\t\tvar p3 = multiply(multiplyByConst(b, p2), [1, a]);\n\n\t\treturn subtract(p3, p1);\n\t}\n\n\tvar m = []; // Sturm chain\n\tm.push(p);\n\tm.push(differentiate(p));\n\n\t//const δ = 10 * Number.EPSILON;\n\tvar i = 1;\n\twhile (m[i].length - 1 > 0) {\n\t\tvar pnext = negRemainder(m[i - 1], m[i]);\n\t\t//pnext = clip(pnext, δ);\n\t\t// If the polynomial degree was not reduced due to roundoff\n\t\t// such that the first 1 or more terms are very small.\n\t\twhile (m[i].length - pnext.length < 1) {\n\t\t\tpnext.shift();\n\t\t}\n\t\t/*\r\n  if (pnext.length === 0) {\r\n  \tbreak;\r\n  }\r\n  */\n\t\tm.push(pnext);\n\n\t\ti++;\n\t}\n\n\treturn m;\n}\n\n/**\r\n * If the highest power coefficient is small in the sense that the \r\n * highest power term has a negligible contribution (compared to the\r\n * other terms) at x = 1 then clip() can be called to remove all such \r\n * highest terms. A contribution of less than Number.EPSILON of the \r\n * highest coefficient will be considered negligible by default.\r\n * \r\n * \r\n * @param {number[]} p - The polynomial to be clipped.\r\n * @param {number} δ_ - The optional contribution tolerence else \r\n *        Number.EPSILON will be used by default.   \r\n * @returns {number[]} The clipped polynomial.\r\n * @example\r\n * FloPoly.clip([1e-18, 1e-10, 1e-5]); //=> [1e-18, 1e-10, 1e-5] \r\n * FloPoly.clip([1e-18, 1e-10, 1e-1]); //=> [1e-10, 1e-1]\r\n */\nfunction clip(p, δ_) {\n\n\tvar δ = δ_ === undefined ? Number.EPSILON : δ_;\n\n\tvar d = p.length - 1;\n\n\tvar c = maxCoefficient(p);\n\tif (c === 0) {\n\t\treturn [];\n\t}\n\n\tif (Math.abs(p[0]) > δ * c) {\n\t\treturn p;\n\t}\n\n\treturn clip(p.slice(1));\n}\n\n/**\r\n * If the highest power coefficient is 0 then clip() can be called to \r\n * remove all such highest terms so that the array is a valid \r\n * presentation of a polynomial.\r\n * \r\n * @param {number[]} p - The polynomial to be clipped.\r\n * @returns {number[]} The clipped polynomial.\r\n * @example\r\n * FloPoly.clip0([1e-18, 1e-10, 1e-1]); //=> [1e-18, 1e-10, 1e-1]\r\n * FloPoly.clip0([0, 1e-10, 1e-1]); //=> [1e-10, 1e-1]\r\n */\nfunction clip0(p) {\n\treturn p[0] !== 0 ? p : clip0(p.slice(1));\n}\n\n/**\r\n * Returns the absolute value of the highest coefficient of the \r\n * polynomial.\r\n * \r\n * @param p {number[]} p - The polynomial.\r\n * @returns {number}\r\n * @example\r\n * FloPoly.maxCoefficient([-2, 0.1, 0.2]); //=> 2\r\n */\nfunction maxCoefficient(p) {\n\tvar max = 0;\n\tfor (var i = 0; i < p.length; i++) {\n\t\tvar c = Math.abs(p[i]);\n\t\tif (c > max) {\n\t\t\tmax = c;\n\t\t}\n\t}\n\n\treturn max;\n}\n\n/**\r\n * Returns a string representing the given polynomial that is readable \r\n * by a human or a CAS (Computer Algebra System).\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {string}\r\n * @example\r\n * FloPoly.toCasStr([5,4,3,2,1]); //=> \"x^4*5 + x^3*4 + x^2*3 + x*2 + 1\"\r\n */\nfunction toCasStr(p) {\n\tvar d = p.length - 1;\n\n\tvar str = '';\n\tfor (var i = 0; i < d + 1; i++) {\n\t\tvar cStr = p[i].toString();\n\t\tif (i === d) {\n\t\t\tstr += cStr;\n\t\t} else if (i === d - 1) {\n\t\t\tstr += 'x*' + cStr + ' + ';\n\t\t} else {\n\t\t\tstr += 'x^' + (d - i).toString() + '*' + cStr + ' + ';\n\t\t}\n\t}\n\n\treturn str;\n}\n\nmodule.exports = coreOperators;\n\n},{}],4:[function(require,module,exports){\n'use strict';\n\nvar coreOperators = require('./core-operators.js');\n\nvar errorAnalysis = {\n  hornerErrorBound: hornerErrorBound\n};\n\nvar evaluate = coreOperators.evaluate;\n\n/**\r\n * <p>\r\n * Approximate condition number for polynomial evaluation multiplied\r\n * by the exact value of the polynomial evaluation.\r\n * </p>\r\n * <p>\r\n * See <a href=\"http://www-pequan.lip6.fr/~jmc/polycopies/Compensation-horner.pdf\">Compensated Horner Scheme - paragraph 1.1</a>\r\n * </p>\r\n * \r\n * @ignore\r\n * @param {number[]} p - The polynomial\r\n * @param {number} x - The evaluation point\r\n * @returns {number} The condition number multiplied exact polynomial \r\n * value at x\r\n */\n\nfunction conditionNumber(p, x) {\n  var d = p.length - 1;\n  var res = 0;\n\n  for (var i = 0; i < d; i++) {\n    res += Math.abs(p[i] * Math.pow(x, d - i));\n  }\n\n  return res;\n}\n\n/**\r\n * <p>\r\n * Classic rule of thumb approximate error bound using Horner's method \r\n * to evaluate polynomials. \r\n * </p>\r\n * <p>\r\n * http://www-pequan.lip6.fr/~jmc/polycopies/Compensation-horner.pdf\r\n * </p>\r\n * @param p {number[]} - The polynomial\r\n * @param x {number} - Value at which polynomial is evaluated. \r\n * @returns {number} The error bound\r\n */\nfunction hornerErrorBound(p, x) {\n  var δ = Number.EPSILON;\n\n  //let pres = evaluate(p,x);\n  //console.log(pres);\n\n  var d = p.length - 1;\n  var res = 2 * d * δ * conditionNumber(p, x);\n  //console.log(res);\n\n  return res;\n}\n\nmodule.exports = errorAnalysis;\n\n},{\"./core-operators.js\":3}],5:[function(require,module,exports){\n'use strict';\n\nvar coreOperators = require('./core-operators.js');\nvar rootOperators = require('./root-operators.js');\nvar rootBounds = require('./root-bounds.js');\nvar allRootsVAS = require('./all-roots-vas.js');\nvar allRootsRecursive = require('./all-roots-recursive.js');\nvar random = require('./random.js');\nvar errorAnalysis = require('./error-analysis.js');\n\nvar multiply = coreOperators.multiply;\n\n/**\r\n* <p>\r\n* Simple & fast practical library functions for functional univariate \r\n* polynomials over the reals (actually ECMAScript numbers, i.e. double \r\n* floats).\r\n* </p>\r\n* <p>\r\n* All polinomials are represented as a simple array starting with the \r\n* highest non-zero power, e.g. \r\n*   3x^3 + 5x^2 + 7x + 2 -> [3,5,7,2]\r\n* </p>\r\n* @ignore\r\n*/\nvar FloPoly = Object.assign({}, coreOperators, rootOperators, rootBounds, { random: random }, {\n  allRoots: allRootsRecursive,\n  //allRootsVAS,\n  fromRoots: fromRoots\n}, errorAnalysis);\n\n/**\r\n * <p>\r\n * Constructs a polynomial from the given roots by multiplying out the \r\n * factors (x - root1)(x - root2)... Note that the resulting polynomial \r\n * will not have any complex roots.\r\n * </p>\r\n * <p>\r\n * Mostly provided for testing purposes. Note that the real roots of the \r\n * constructed polynomial may not be exactly the same as the roots that\r\n * the polynomial has been constructed from due to floating-point \r\n * round-off.\r\n * </p>\r\n * \r\n * @param {number[]} roots - The roots\r\n * @returns {number[]} The constructed polynomial.\r\n * @example\r\n * FloPoly.fromRoots([1,2,3,3]); //=> [1, -9, 29, -39, 18]\r\n * FloPoly.allRoots([1, -9, 29, -39, 18]); //=> [1.0000000000000007, 2.000000000000004]\r\n * // In the above note the rounding error. Also note the multiple root of 3 that has been missed but as stated previously this does not generally pose a problem for even multiple roots. See the examples below.\r\n * FloPoly.allRoots([1, -9, 29, -39, 17.99999999999999]); //=> [0.9999999999999973, 2.00000000000002, 2.9999999999999982]\r\n * FloPoly.allRoots([1, -9, 29, -39, 17.9999999999999]); //=> [0.999999999999975, 2.0000000000000986, 2.9999997898930832, 3.0000002095475775]\r\n */\nfunction fromRoots(roots) {\n  var p = [1];\n  for (var i = 0; i < roots.length; i++) {\n    p = multiply(p, [1, -roots[i]]);\n  }\n\n  return p;\n}\n\nif (module !== undefined && module.exports !== undefined) {\n  // Node\n  module.exports = exports = FloPoly;\n} else {\n  // Browser\n  window.FloPoly = FloPoly;\n}\n\n},{\"./all-roots-recursive.js\":1,\"./all-roots-vas.js\":2,\"./core-operators.js\":3,\"./error-analysis.js\":4,\"./random.js\":7,\"./root-bounds.js\":8,\"./root-operators.js\":9}],6:[function(require,module,exports){\n'use strict';\n\n/** \r\n * Mobius namespaced functions, i.e. M(x) = (ax + b) / (cx + d) where \r\n * a,b,c and d are constants. Represented as a 2-diminsional array \r\n * [[a,b],[c,d]].\r\n * \r\n * @ignore\r\n * @namespace\r\n */\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar Mobius = {};\n\n/**\r\n * Performs a change of variables x → ax + b on p(x) where\r\n * it is a precondition on the polynomial p that deg(p) = 1.\r\n *\r\n * @ignore\r\n * @param {number[]} p - The degree 1 polynomial p(x)\r\n * @param {number} a\r\n * @param {number} b\r\n * @returns {number[]} The modified polynomial p(ax + b). \r\n */\nfunction changeVariables1(p, a, b) {\n  return [a * p[0], p[1] + b * p[0]];\n}\n\n/**\r\n * Performs a change of variables x → px + q on the given Mobius \r\n * function. \r\n *\r\n * @ignore\r\n * @param {number[][]} mobius - The mobius function \r\n * M(x) = (ax + b) / (cx + d) represented as [[a,b],[c,d]]\r\n * @param {number} a\r\n * @param {number} b\r\n * @returns {number[][]} The modified mobius function \r\n * M(x) = (a(px + q) + b) / (c(px + q) + d). \r\n */\nMobius.changeVariables = function (mobius, a, b) {\n  return [changeVariables1(mobius[0], a, b), changeVariables1(mobius[1], a, b)];\n};\n\n/**\r\n * Inverts the given mobius, i.e.\r\n * M(x) = (ax + b) / (cx + d) → (bx + a) / (dx + c)\r\n * \r\n * @ignore\r\n * @param {number[][]} mobius - The mobius function \r\n * M(x) = (ax + b) / (cx + d) represented as [[a,b],[c,d]]\r\n * @returns {number[][]} The modified mobius function. \r\n */\nMobius.invert = function (mobius) {\n  var _mobius = _slicedToArray(mobius, 2),\n      _mobius$ = _slicedToArray(_mobius[0], 2),\n      a = _mobius$[0],\n      b = _mobius$[1],\n      _mobius$2 = _slicedToArray(_mobius[1], 2),\n      c = _mobius$2[0],\n      d = _mobius$2[1];\n\n  return [[b, a], [d, c]];\n};\n\n/**\r\n * Evaluates the given mobius function at x = 0.\r\n * \r\n * @ignore\r\n * @param {number[][]} mobius - The mobius function \r\n * M(x) = (ax + b) / (cx + d) represented as [[a,b],[c,d]]\r\n * @returns {number} The result of the evaluation.\r\n */\nMobius.evaluateAt0 = function (mobius) {\n  return mobius[0][1] / mobius[1][1];\n};\n\n/**\r\n * Evaluates the given mobius function in the limit as x → ∞.\r\n * \r\n * @ignore\r\n * @param {number[][]} mobius - The mobius function \r\n * M(x) = (ax + b) / (cx + d) represented as [[a,b],[c,d]]\r\n * @returns {number} The result of the evaluation.\r\n */\nMobius.evaluateAtInf = function (mobius) {\n  return mobius[0][0] / mobius[1][0];\n};\n\n/**\r\n * Evaluates the given mobius function at a specific x.\r\n * \r\n * @ignore\r\n * @param {number[][]} mobius - The mobius function\r\n * @param {number} x - The x value at which to evaluate\r\n * M(x) = (ax + b) / (cx + d) represented as [[a,b],[c,d]]\r\n * @returns {number} The result of the evaluation.\r\n */\nMobius.evaluate = function (mobius, x) {\n  var _mobius2 = _slicedToArray(mobius, 2),\n      _mobius2$ = _slicedToArray(_mobius2[0], 2),\n      a = _mobius2$[0],\n      b = _mobius2$[1],\n      _mobius2$2 = _slicedToArray(_mobius2[1], 2),\n      c = _mobius2$2[0],\n      d = _mobius2$2[1];\n\n  return (a * x + b) / (c * x + d);\n};\n\nmodule.exports = Mobius;\n\n},{}],7:[function(require,module,exports){\n'use strict';\n\n/**\r\n * Some seed value for the simple random number generator.\r\n * @ignore\r\n */\n\nvar SEED = 123456789;\n\n/**\r\n * The range for the simple random number generator, i.e. the generated\r\n * numbers will be in [0,RANGE].\r\n * @ignore\r\n */\nvar RANGE = 4294967296;\n\n/**\r\n * Generates an array of random polynomials with parameters as specified \r\n * by flatRoots. The exact same polynomials will be created on each\r\n * call to this function if the same seed is used - this is by design to \r\n * improve testability.\r\n *   \r\n * @memberof random\r\n * @param {number} n - The number of polynomials to generate.\r\n * @param {number} d - The degree of the polynomials \r\n * @param {number} a - The lower bound of the distribution - defaults \r\n * to 0\r\n * @param {number} b - The upper bound of the distribution - defaults \r\n * to 1\r\n * @param {number} seed - A seed value for generating random values (so\r\n * that the results are reproducable)\r\n * @param {number} odds - The odds that a root will be doubled (applied\r\n * recursively so that some roots will be tripled, etc. - defaults to 0\r\n * @returns {number[][]} The array of random polynomials.\r\n * @example\r\n * FloPoly.random.flatRootsArr(2,3,0,10); //=> [[1, -17.27247918024659, 97.33487287168995, -179.34094494147305], [1, -14.934967160224915, 57.624514485645406, -14.513933300587215]]\r\n * FloPoly.random.flatRootsArr(2,3,0,10); //=> [[1, -17.27247918024659, 97.33487287168995, -179.34094494147305], [1, -14.934967160224915, 57.624514485645406, -14.513933300587215]]\r\n */\nvar flatRootsArr = createArrFunction(flatRoots);\n\n/**\r\n * Generates an array of random polynomials as specified by \r\n * flatCoefficients. The exact same polynomials will be created on each\r\n * call to this function if the same seed is used - this is by design to \r\n * improve testability.\r\n *   \r\n * @memberof random\r\n * @param {number} n - The number of polynomials to generate.\r\n * @param {number} d - The degree of the polynomials \r\n * @param {number} a - The lower bound of the distribution - defaults \r\n * to 0\r\n * @param {number} b - The upper bound of the distribution - defaults \r\n * to 1\r\n * @param {number} seed - A seed value for generating random values (so\r\n * that the results are reproducable)\r\n * @returns {number[][]} The array of random polynomials.\r\n * @example\r\n * FloPoly.random.flatCoefficientsArr(2,3,-2,2); //=> [[0.1749166026711464, -0.20349335670471191, 0.9375684261322021], [1.0617692470550537, -1.8918039798736572, 0.8040215969085693]]\r\n * FloPoly.random.flatCoefficientsArr(2,3,-2,2); //=> [[0.1749166026711464, -0.20349335670471191, 0.9375684261322021], [1.0617692470550537, -1.8918039798736572, 0.8040215969085693]]\r\n */\nvar flatCoefficientsArr = createArrFunction(flatCoefficients);\n\nvar random = {\n  flatRoots: flatRoots,\n  flatRootsArr: flatRootsArr,\n  flatCoefficients: flatCoefficients,\n  flatCoefficientsArr: flatCoefficientsArr\n};\n\n/**\r\n * https://stackoverflow.com/questions/3062746/special-simple-random-number-generator\r\n * \r\n * @ignore\r\n * @param {number} seed\r\n * @returns {number} A quasi-random number to be used as the next input \r\n * to this function.\r\n */\nfunction predictiveRandom(seed) {\n  var a = 134775813;\n\n  return (a * seed + 1) % RANGE;\n}\n\n/**\r\n * Generates a random array of numbers picked from a bounded flat \r\n * distribution (i.e. a rectangular distribution) with specified odds of \r\n * duplication of consecutive values.\r\n *   \r\n * @ignore\r\n * @param {number} n - The number of values to generate.\r\n * @param {number} a - The lower bound of the distribution - defaults \r\n * to 0\r\n * @param {number} b - The upper bound of the distribution - defaults \r\n * to 1\r\n * @param {number} seed - A seed value for generating random values (so\r\n * that the results are reproducable)\r\n * @param {number} odds - The odds that a root will be doubled (applied\r\n * recursively so that some roots will be tripled, etc. - defaults to 0\r\n * @returns {number[]} - The random array.\r\n */\nfunction randomArray(n, a, b, seed, odds) {\n  seed = seed || SEED;\n  odds = odds || 0;\n\n  var vs = [];\n  for (var i = 0; i < n; i++) {\n    seed = predictiveRandom(seed);\n    var v = seed / RANGE * (b - a) + a;\n    seed = push(seed, vs, v, odds);\n  }\n  vs = vs.slice(0, n);\n\n  return { vs: vs, seed: seed };\n}\n\n/**\r\n * Helper function that will add more numbers to the passed array - \r\n * modifies the values parameter.\r\n *\r\n * @ignore\r\n * @param {number[]} values - An existing array of values - will be \r\n * modified!\r\n * @param {number} x - The number that will be added (possibly\r\n * multiple times)\r\n * @param {number} odds - The odds that the number will be added\r\n * again (recursively). \r\n */\nfunction push(seed, values, x, odds) {\n  seed = predictiveRandom(seed);\n\n  values.push(x);\n  if (seed / RANGE < odds) {\n    seed = push(seed, values, x, odds);\n  }\n\n  return seed;\n}\n\n/**\r\n * Generates a random polynomial with roots picked from a bounded flat \r\n * distribution (i.e. a rectangular distribution) with specified odds of \r\n * duplication of consecutive values. Note that the resulting polynomial\r\n * won't have any complex roots.\r\n * \r\n * @memberof random\r\n * @param {number} d - The degree of the polynomials \r\n * @param {number} a - The lower bound of the distribution - defaults \r\n * to 0\r\n * @param {number} b - The upper bound of the distribution - defaults \r\n * to 1\r\n * @param {number} seed - A seed value for generating random values (so\r\n * that the results are reproducable)\r\n * @param {number} odds - The odds that a root will be doubled (applied\r\n * recursively so that some roots will be tripled, etc. - defaults to 0\r\n * @returns {{p: number[], seed: number}} a random polynomial and the\r\n * last seed value to reuse.\r\n * @example\r\n * FloPoly.random.flatRoots(3,0,10); //=> { p: [1, -17.27247918024659, 97.33487287168995, -179.34094494147305], seed: 939629312 }\r\n */\nfunction flatRoots(d, a, b, seed, odds) {\n  a = a || 0;\n  b = b || 1;\n  seed = seed || SEED;\n  odds = odds || 0;\n\n  var randArr = randomArray(d, a, b, seed, odds);\n  seed = randArr.seed;\n\n  // TODO - fix line below by first requiring fromRoots and then remove FloPoly.\n  var p = FloPoly.fromRoots(randArr.vs);\n\n  return { p: p, seed: seed };\n}\n\n/**\r\n * Generates a random polynomial with coefficients picked from a bounded \r\n * flat distribution (i.e. a rectangular distribution). \r\n * \r\n * @memberof random\r\n * @param {number} d - The degree of the polynomials \r\n * @param {number} a - The lower bound of the distribution - defaults \r\n * to -1\r\n * @param {number} b - The upper bound of the distribution - defaults \r\n * to 1\r\n * @param {number} seed - A seed value for generating random values (so\r\n * that the results are reproducable)\r\n * @returns {{p: number[], seed: number}} a random polynomial and the\r\n * last seed value to reuse.\r\n * @example\r\n * FloPoly.random.flatCoefficients(3,-5,5); //=> { p: [0.437291506677866, -0.5087333917617798, 2.3439210653305054], seed: 939629312 }\r\n */\nfunction flatCoefficients(d, a, b, seed) {\n  a = a || -1;\n  b = b || 1;\n  seed = seed || SEED;\n\n  var randArr = randomArray(d, a, b, seed);\n  seed = randArr.seed;\n\n  var p = randArr.vs;\n\n  return { p: p, seed: seed };\n}\n\n/**\r\n * Creates a function from the given function with parameters similar\r\n * to flatRoots but with an extra parameter in the beginning indicating\r\n * the length of the array generated by the original function.\r\n * \r\n * @ignore\r\n * @param {function} f\r\n * @returns {function}\r\n */\nfunction createArrFunction(f) {\n  return function (n, d, a, b, seed, odds) {\n    seed = seed || SEED;\n    var res = [];\n\n    for (var i = 0; i < n; i++) {\n      var v = f(d, a, b, seed, odds);\n      var p = v.p;\n      seed = v.seed;\n\n      res.push(p);\n    }\n\n    return res;\n  };\n}\n\nmodule.exports = random;\n\n},{}],8:[function(require,module,exports){\n'use strict';\n\nvar coreOperators = require('./core-operators.js');\n\nvar invert = coreOperators.invert,\n    negate = coreOperators.negate,\n    reflectAboutYAxis = coreOperators.reflectAboutYAxis;\n\n\nvar rootBounds = {\n\trootMagnitudeUpperBound_fujiwara: rootMagnitudeUpperBound_fujiwara,\n\tpositiveRootUpperBound_LMQ: positiveRootUpperBound_LMQ,\n\tpositiveRootLowerBound_LMQ: positiveRootLowerBound_LMQ,\n\tnegativeRootUpperBound_LMQ: negativeRootUpperBound_LMQ,\n\tnegativeRootLowerBound_LMQ: negativeRootLowerBound_LMQ\n};\n\n/**\r\n * Finds an upper bound on the magnitude (absolute value) of the roots\r\n * of the given polynomial using the near-optimal Fujiwara bound.\r\n * \r\n * @see https://en.wikipedia.org/wiki/Properties_of_polynomial_roots#cite_note-Fujiwara1916-4\r\n * \r\n * @param {number[]} p - The polynomial.\r\n * @returns {number} The bounds.\r\n * @note Not yet adjusted for floating-point error. Tight bounds but\r\n * slow due to usage of Math.pow.\r\n * @example\r\n * FloPoly.rootMagnitudeUpperBound_fujiwara([2,-3,6,5,-130]); //=> 6.753296750770361\r\n * FloPoly.allRoots([2,-3,6,5,-130]); //=> [-2.397918624065303, 2.8793785310848383]\r\n */\nfunction rootMagnitudeUpperBound_fujiwara(p) {\n\tvar d = p.length - 1;\n\n\tvar an = p[0];\n\tvar bs = [];\n\n\tfor (var i = 1; i < d; i++) {\n\t\tvar b = Math.pow(Math.abs(p[i] / an), 1 / i);\n\t\tbs.push(b);\n\t}\n\n\tbs.push(Math.pow(Math.abs(p[d] / 2 * an), 1 / d));\n\n\treturn 2 * Math.max.apply(undefined, bs);\n}\n\n/**\r\n * <p> \r\n * Returns an upper bound for the positive roots of the given \r\n * polynomial.\r\n * </p>\r\n * <p>\r\n * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński, \r\n * specifically the LocalMaxQuadratic algorithm hence LMQ.\r\n * </p>  \r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number} A lower bound.\r\n * @example\r\n * FloPoly.positiveRootUpperBound_LMQ([2,-3,6,5,-130]); //=> 4.015534272870436 \r\n * FloPoly.positiveRootUpperBound_LMQ([2,3]);           //=> 0 \r\n * FloPoly.positiveRootUpperBound_LMQ([-2,-3,-4]);      //=> 0\r\n */\nfunction positiveRootUpperBound_LMQ(p) {\n\tvar deg = p.length - 1;\n\tif (deg < 1) {\n\t\treturn 0;\n\t}\n\n\tif (p[0] < 0) {\n\t\tp = negate(p);\n\t}\n\n\tvar timesUsed = [];\n\tfor (var i = 0; i < deg; i++) {\n\t\ttimesUsed.push(1);\n\t}\n\n\tvar ub = 0;\n\n\tfor (var m = 0; m <= deg; m++) {\n\t\tif (p[m] >= 0) continue;\n\n\t\tvar tempub = Number.POSITIVE_INFINITY;\n\t\tvar any = false;\n\n\t\tfor (var k = 0; k < m; k++) {\n\t\t\tif (p[k] <= 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// TODO - Both these pows can easily be replaced with a \n\t\t\t// lookup that may speed things up a lot since (for low \n\t\t\t// order polys) it will most of the time be a square, \n\t\t\t// cube... root or multiplication by 1,2,4,8,...\n\t\t\tvar temp = Math.pow(-p[m] / (p[k] / Math.pow(2, timesUsed[k])), 1 / (m - k));\n\n\t\t\ttimesUsed[k]++;\n\n\t\t\tif (tempub > temp) {\n\t\t\t\ttempub = temp;\n\t\t\t}\n\n\t\t\tany = true;\n\t\t}\n\n\t\tif (any && ub < tempub) ub = tempub;\n\t}\n\n\treturn ub;\n}\n\n/**\r\n * <p> \r\n * Calculates a lower bound for the positive roots of the given \r\n * polynomial.\r\n * </p>\r\n * <p>\r\n * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński, \r\n * specifically the LocalMaxQuadratic algorithm hence LMQ.\r\n * </p>\r\n *  \r\n * @param {number[]} p - The polynomial\r\n * @returns {number} A lower bound.\r\n * @example\r\n * FloPoly.positiveRootLowerBound_LMQ([2,-3,6,5,-130]); //=> 1.6883241876925903\r\n * FloPoly.positiveRootLowerBound_LMQ([2,3]);           //=> 0 \r\n * FloPoly.positiveRootLowerBound_LMQ([-2,-3,-4]);      //=> 0\r\n */\nfunction positiveRootLowerBound_LMQ(p) {\n\tvar ub = positiveRootUpperBound_LMQ(invert(p));\n\tif (ub === 0) {\n\t\treturn 0;\n\t}\n\treturn 1 / ub;\n}\n\n/**\r\n * See positiveRootUpperBound_LMQ\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number} An upper bound.\r\n */\nfunction negativeRootUpperBound_LMQ(p) {\n\treturn -positiveRootLowerBound_LMQ(reflectAboutYAxis(p));\n}\n\n/**\r\n * See positiveRootLowerBound_LMQ\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number} A lower bound.\r\n */\nfunction negativeRootLowerBound_LMQ(p) {\n\treturn -positiveRootUpperBound_LMQ(reflectAboutYAxis(p));\n}\n\nmodule.exports = rootBounds;\n\n},{\"./core-operators.js\":3}],9:[function(require,module,exports){\n'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar coreOperators = require('./core-operators.js');\n\n/**\r\n * Operators (i.e. functions) directly related to roots and root \r\n * finding. \r\n * \r\n * @ignore\r\n */\nvar rootOperators = {\n  quadraticRoots: quadraticRoots,\n  //cubicRoots,\n  numRootsWithin: numRootsWithin,\n  brent: brent,\n  coreOperators: coreOperators\n};\n\nvar sturmChain = coreOperators.sturmChain,\n    evaluate = coreOperators.evaluate,\n    signChanges = coreOperators.signChanges;\n\n/**\r\n * Floating-point-stably calculates and returns the ordered quadratic \r\n * roots of the given quadratic polynomial.\r\n * \r\n * @param {number[]} p - The 2nd order polynomial\r\n * @returns {number[]} The found quadratic roots.\r\n * @example \r\n * FloPoly.quadraticRoots([1, -3, 2]); //=> [1,2]\r\n */\n\nfunction quadraticRoots(p) {\n  var _p = _slicedToArray(p, 3),\n      a = _p[0],\n      b = _p[1],\n      c = _p[2];\n\n  var delta = b * b - 4 * a * c;\n\n  if (delta < 0) {\n    // No real roots;\n    return [];\n  }\n\n  if (delta === 0) {\n    return [-b / (2 * a)];\n  }\n\n  delta = Math.sqrt(delta);\n\n  var root1 = void 0;\n  var root2 = void 0;\n  if (b >= 0) {\n    root1 = (-b - delta) / (2 * a);\n    root2 = 2 * c / (-b - delta);\n  } else {\n    root1 = 2 * c / (-b + delta);\n    root2 = (-b + delta) / (2 * a);\n  }\n\n  if (root1 < root2) {\n    return [root1, root2];\n  }\n  return [root2, root1];\n}\n\n/**\r\n * Calculates the roots of the given cubic polynomial.\r\n * \r\n * This code is mostly from the Pomax guide found at\r\n * https://pomax.github.io/bezierinfo/#extremities\r\n * \r\n * @param {number[]} p - A cubic polynomial.\r\n * @returns {number[]} 1,2 or 3 roots.\r\n */\n// TODO - This function as it currently stands is very sensitive to\n// the first coefficient if it is very small, e.g. compare:\n// cubicRoots([1e-5, 1560,-1740,96]) = [1.1903631761670113, -156000001.1153846, -0.07497859001159668] \n// vs\n// quadraticRoots([1560,-1740,96]) = [0.05821032751613551, 1.0571742878684798]\n// It is completely useless in some ranges of its input domain:\n// the part of the function 'if (discriminant < 0) {}'\n// is highly problematic for numerical stability.\n// Simply use allRoots / allRootsRecursive instead.\n/*\r\nfunction cubicRoots(p) {\r\n\r\n\tfunction cuberoot(v) {\r\n\t\treturn v < 0 \r\n\t\t\t? -Math.pow(-v, 1/3)\r\n\t\t    : +Math.pow(v, 1/3);\r\n\t}\r\n\t\r\n\tlet cbrt = Math.cbrt || cuberoot;\r\n\t\r\n\tlet d = p[0];\r\n\tlet a = p[1] / d;\r\n\tlet b = p[2] / d;\r\n\tlet c = p[3] / d;\r\n\t\r\n\tlet s  = (3*b - a*a) / 9;\r\n\tlet q  = (2*a*a*a - 9*a*b + 27*c) / 54;\r\n\t\r\n\tlet s3 = s*s*s;\r\n\tlet q2 = q*q;\r\n\t\r\n\tlet discriminant = q2 + s3;\r\n\r\n\tif (!Number.isFinite(discriminant)) {\r\n\t\t\r\n\t\t// Overflow occured - in which case one root will be very large. \r\n\t\t// We might want to report such large roots as positive or\r\n\t\t// negative infinity but since they are rarely of interest we\r\n\t\t// report only the smaller roots.\r\n\t\t\r\n\t\t// Here q*q   === (729*c^2 - 486*a*b*c + 108*a^3*c + 81*a^2*b^2 - 36*a^4*b + 4*a^6) / (729*4)\r\n\t\t// and  s*s*s === (27*b^3 - 27*a^2*b^2 + 9*a^4*b - a^6) / (729*1)\r\n\t\t\r\n\t\treturn quadraticRoots(p.slice(1)); \r\n\t}\r\n\t\r\n\tif (discriminant < 0) {\r\n\t\t// three real roots\r\n\t\t\r\n\t\tlet r = Math.sqrt(-s3);\r\n\t\tlet t = -q / r;\r\n\t\t\r\n\t\tlet cosphi = t < -1 ? -1 : t > 1 ? 1 : t;\r\n\t\tlet phi    = Math.acos(cosphi);\r\n\t\tlet\tt1     = 2*cbrt(r);\r\n\t\t\r\n\t\tlet ao3 = a/3; \r\n\t\t\r\n\t\treturn [\r\n\t\t\tt1*Math.cos((phi            )/3) - ao3, \r\n\t\t\tt1*Math.cos((phi + 2*Math.PI)/3) - ao3, \r\n\t\t\tt1*Math.cos((phi + 4*Math.PI)/3) - ao3\r\n\t\t]\r\n\t} else if (discriminant === 0) {\r\n\t\t// three real roots, but two of them are equal\r\n\t\t\r\n\t\tlet u1 = q < 0 ? cbrt(-q) : -cbrt(q);\r\n\t\tlet ao3 = a/3;\r\n\t\t\r\n\t\treturn [\r\n\t\t\t2*u1 - ao3, \r\n\t\t\t-u1 - ao3\r\n\t\t];\r\n\t} else {\r\n\t\t// one real root, two complex roots\r\n\t\t\r\n\t\tlet sd = Math.sqrt(discriminant);\r\n\t\tlet u1 = cbrt(sd - q);\r\n\t\tlet v1 = cbrt(sd + q);\r\n\t\t\r\n\t\treturn [u1 - v1 - a/3];\r\n\t}\r\n}\r\n*/\n\n/** \r\n * Returns the number of real roots in the interval (a,b) of the given \r\n * polynomial.\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @param {number} a - The lower bound\r\n * @param {number} b - The upper bound\r\n * @returns {number} The number of roots in the given interval\r\n * @example \r\n * let p = [1, 1, -64, 236, -240];\r\n * FloPoly.numRootsWithin(p,-20,-11); //=> 0\r\n * FloPoly.numRootsWithin(p,-11,-9);  //=> 1  \r\n * FloPoly.numRootsWithin(p,-11,3.5); //=> 3\r\n * FloPoly.numRootsWithin(p,-11,5);   //=> 4\r\n */\nfunction numRootsWithin(p, a, b) {\n  var ps = sturmChain(p);\n  var ev = evaluate(p);\n  var as = ps.map(function (p) {\n    return evaluate(p)(a);\n  });\n  var bs = ps.map(function (p) {\n    return evaluate(p)(b);\n  });\n\n  return signChanges(as) - signChanges(bs);\n}\n\n/**\r\n * <p>\r\n * Searches an interval (a,b) for a root (i.e. zero) of the \r\n * given function with respect to its first argument using the Brent's \r\n * Method root-finding algorithm. Any function can be supplied (it does\r\n * not even have to be continuous) as long as the root is bracketed. \r\n * </p>\r\n * <p>\r\n * Brent's Method is an excellent root-finding choice since it is\r\n * (1) guaranteed to converge (unlike the Newton and other so-called \r\n * single-point methods), (2) converges in a reasonable number of \r\n * iterations even for highly contrived functions (unlike Dekker's \r\n * Method) and (3) nearly always converges extremely fast, i.e. super-\r\n * linearly (unlike the Secant and Regula-Falsi methods).\r\n * </p>\r\n * <p>\r\n * The max error, δ, is set equal to 2*Number.EPSILON*Math.abs(b) \r\n * + Number.EPSILON after each iteration where b is the current best \r\n * guess. A much larger δ of say 1e-10 does not really make sense\r\n * for polynomials since nearly always by that stage convergence \r\n * proceeds superlinearly and by the next iteration a δ of\r\n * around Number.EPSILON is achieved. On the other hand, a δ of \r\n * much less than Number.EPSILON is sometimes useful, say for finding  \r\n * the root of the polynomial x**2 - 3*x*1e-13 + 2*1e-26 to within less\r\n * than 1e-15, but this is rare enough not to be considered in this \r\n * implementation. (For JavaScript doubles Number.EPSILON === \r\n * 2.220446049250313e-16 and since b is typically around 1 the max δ \r\n * will be about 3*2.220446049250313e-16 or about 1e-15. As another \r\n * example, a root near -1000 will have a max error, i.e. δ, of \r\n * about 1e-12. In conclusion, for roots near zero the error can be up\r\n * to Number.EPSILON or about 1e-15 - we don't bother to calculate the\r\n * root more accurately than this since it may require up to 4 or 5 \r\n * additional iterations.\r\n * </p>\r\n * <p> \r\n * See <a href=\"https://en.wikipedia.org/wiki/Brent%27s_method\">Wikipedia</a>\r\n * </p>\r\n * <p>\r\n * See <a href=\"https://maths-people.anu.edu.au/~brent/pd/rpb011i.pdf\">Brent (page 47)</a>\r\n * </p>\r\n * @param {function} f - The function for which the root is sought.\r\n * @param {number} a - The lower limit of the search interval.\r\n * @param {number} b - The upper limit of the search interval.\r\n * @returns {number} An estimate of the root to within δ (typically \r\n * about 1e-15).\r\n * @example\r\n * let p = FloPoly.fromRoots([-10,2,3,4]);  //=> [1, 1, -64, 236, -240]\r\n * let f = FloPoly.evaluate(p);\r\n * FloPoly.brent(f,2.2,3.8); //=> 3.000000000000003\r\n * FloPoly.brent(f,2.2,3.1); //=> 3.000000000000001\r\n */\nfunction brent(f, a, b) {\n  var EPS = Number.EPSILON;\n\n  if (a === b) {\n    // Presumably the root is already found.\n    return a;\n  }\n\n  // We assume on the first iteration f(a) !== 0 && f(b) !== 0. \n  var fa = f(a);\n  var fb = f(b);\n\n  if (fa * fb > 0) {\n    // Root is not bracketed - this is a precondition.\n    throw 'Root not bracketed';\n  }\n\n  var c = void 0; // Value of previous guess - set to a initially \n  if (Math.abs(fa) < Math.abs(fb)) {\n    // Swap a,b\n    c = a;a = b;b = c;\n\n    // Swap fa,fb\n    var temp = fa;\n    fa = fb;\n    fb = temp;\n  }\n\n  c = a;\n\n  var mflag = true;\n  var d = void 0; // Value of guess before previous guess\n  while (true) {\n    var δ = 2 * EPS * Math.abs(b) + EPS;\n\n    var fc = f(c);\n\n    // Calculate provisional interpolation value\n    var s = void 0;\n    if (fa !== fc && fb !== fc) {\n      // 3 points available - inverse quadratic interpolation\n      var fac = fa - fc;\n      var fab = fa - fb;\n      var fbc = fb - fc;\n\n      // The below has been multiplied out to speed up the algorithm.\n      /*s = ((a * fb * fc) / ( fab * fac)) +\r\n      \t  ((b * fa * fc) / (-fab * fbc)) +\r\n      \t  ((c * fa * fb) / ( fac * fbc));*/\n      s = ((a * fb * fbc - b * fa * fac) * fc + c * fa * fab * fb) / (fab * fac * fbc);\n    } else {\n      // only 2 points available - secant method\n      s = b - fb * ((b - a) / (fb - fa));\n    }\n\n    var t1 = (3 * a + b) / 4;\n    var b_c = Math.abs(b - c);\n    var s_b = Math.abs(s - b);\n    var c_d = Math.abs(c - d);\n\n    if (!( // condition 1\n    s > t1 && s < b || s < t1 && s > b) || mflag && (\n    // condition 2\n    s_b >= b_c / 2 ||\n    // condition 4\n    b_c < δ) || !mflag && (\n    // condition 3\n    s_b >= c_d / 2 ||\n    // condition 5\n    c_d < δ)) {\n      // Bisection\n      s = (a + b) / 2;\n      mflag = true;\n    } else {\n      mflag = false;\n    }\n\n    var fs = f(s);\n\n    d = c;\n    c = b;\n\n    if (fa * fs < 0) {\n      b = s;\n    } else {\n      a = s;\n    }\n\n    if (Math.abs(fa) < Math.abs(fb)) {\n      // Swap a,b\n      var _temp = a;a = b;b = _temp;\n    }\n\n    if (fb === 0) {\n      return b;\n    }\n    if (fs === 0) {\n      return s;\n    }\n\n    if (Math.abs(a - b) <= δ) {\n      return b;\n    }\n\n    fa = f(a);\n    fb = f(b);\n  }\n}\n\nmodule.exports = rootOperators;\n\n},{\"./core-operators.js\":3}]},{},[5])(5)\n});"]}